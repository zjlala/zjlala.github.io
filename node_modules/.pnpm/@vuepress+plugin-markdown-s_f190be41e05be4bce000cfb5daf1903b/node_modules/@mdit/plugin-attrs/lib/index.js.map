{"version":3,"file":"index.js","sources":["../src/helper/constants.ts","../src/helper/getAttrs.ts","../src/helper/addAttrs.ts","../src/helper/getDelimiterChecker.ts","../src/helper/getMatchingOpeningToken.ts","../src/utils.ts","../src/helper/testRule.ts","../src/rules/block.ts","../src/rules/fence.ts","../src/rules/heading.ts","../src/rules/inline.ts","../src/rules/list.ts","../src/rules/softbreak.ts","../src/rules/hr.ts","../src/rules/table.ts","../src/rules/rules.ts","../src/plugin.ts"],"sourcesContent":["/** . */\nexport const CLASS_MARKER = 46;\n/** # */\nexport const ID_MARKER = 35;\n/** space */\nexport const PAIR_SEPARATOR = 32;\n/** = */\nexport const KEY_SEPARATOR = 61;\n/** \" */\nexport const QUOTE_MARKER = 34;\n","import {\n  CLASS_MARKER,\n  ID_MARKER,\n  KEY_SEPARATOR,\n  PAIR_SEPARATOR,\n  QUOTE_MARKER,\n} from \"./constants.js\";\nimport type { Attr } from \"./types.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nconst isAllowedKeyChar = (charCode: number): boolean =>\n  !(\n    charCode === 9 /* \\t */ ||\n    charCode === 10 /* \\n */ ||\n    charCode === 12 /* \\f */ ||\n    charCode === 32 /* 空格 */ ||\n    charCode === 47 /* / */ ||\n    charCode === 62 /* > */ ||\n    charCode === 34 /* \" */ ||\n    charCode === 39 /* ' */ ||\n    charCode === 61 /* = */\n  );\n\nexport const getAttrs = (\n  str: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): Attr[] => {\n  let key = \"\";\n  let value = \"\";\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  const attrs: Attr[] = [];\n\n  // read inside marker\n  // start + left delimiter length to avoid beginning marker\n  // breaks when ending marker is found or end of string\n  for (let index = range[0]; index < range[1]; index++) {\n    const charCode = str.charCodeAt(index);\n\n    // switch to reading value if equal sign\n    if (charCode === KEY_SEPARATOR && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (charCode === CLASS_MARKER && key === \"\") {\n      if (str.charCodeAt(index + 1) === CLASS_MARKER) {\n        key = \"css-module\";\n        index++;\n      } else {\n        key = \"class\";\n      }\n\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (charCode === ID_MARKER && key === \"\") {\n      key = \"id\";\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (charCode === QUOTE_MARKER && value === \"\" && !valueInsideQuotes) {\n      valueInsideQuotes = true;\n      continue;\n    }\n\n    if (charCode === QUOTE_MARKER && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if (charCode === PAIR_SEPARATOR && !valueInsideQuotes) {\n      if (key === \"\")\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n\n      attrs.push([key, value]);\n      key = \"\";\n      value = \"\";\n      parsingKey = true;\n\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && !isAllowedKeyChar(charCode)) continue;\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += String.fromCharCode(charCode);\n      continue;\n    }\n\n    value += String.fromCharCode(charCode);\n  }\n\n  // append last key/value pair\n  if (key !== \"\") attrs.push([key, value]);\n\n  return allowed.length\n    ? attrs.filter(([attr]) =>\n        allowed.some((item) =>\n          item instanceof RegExp ? item.test(attr) : item === attr,\n        ),\n      )\n    : attrs;\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport { getAttrs } from \"./getAttrs.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nexport const addAttrs = (\n  token: Token | null,\n  content: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): void => {\n  if (!token) return;\n\n  getAttrs(content, range, allowed).forEach(([key, value]) => {\n    switch (key) {\n      case \"class\":\n        token.attrJoin(\"class\", value);\n        break;\n      case \"css-module\":\n        token.attrJoin(\"css-module\", value);\n        break;\n      default:\n        token.attrPush([key, value]);\n    }\n  });\n};\n","import { CLASS_MARKER, ID_MARKER } from \"./constants.js\";\nimport type { DelimiterConfig } from \"./types.js\";\nimport type { DelimiterChecker } from \"../rules/types.js\";\n\n/**\n * Get a function to check if a string matches the delimiter pattern\n * 获取一个函数来检查字符串是否匹配分隔符模式\n *\n * @param options - Delimiter configuration / 分隔符配置\n * @param where - Position for matching: start, end, or only / 匹配位置：开始、结束或仅匹配\n * @returns A function that checks if content matches the delimiter pattern / 检查内容是否匹配分隔符模式的函数\n */\nexport const getDelimiterChecker = (\n  { left, right }: DelimiterConfig,\n  where: \"start\" | \"end\" | \"only\",\n): DelimiterChecker => {\n  if (![\"start\", \"end\", \"only\"].includes(where)) {\n    throw new Error(\n      `Invalid 'where' parameter: ${where}. Expected 'start', 'end', or 'only'.`,\n    );\n  }\n\n  // Cache frequently used values\n  const leftLength = left.length;\n  const rightLength = right.length;\n  const minContentLength = leftLength + 1 + rightLength;\n\n  return (content) => {\n    // Quick check for minimum length requirements\n    if (typeof content !== \"string\" || content.length < minContentLength)\n      return false;\n\n    let start: number;\n    let end: number;\n\n    if (where === \"start\") {\n      // Check if content starts with left delimiter\n      if (!content.startsWith(left)) return false;\n\n      start = leftLength;\n      end = content.indexOf(right, leftLength + 1);\n\n      if (end === -1) return false;\n\n      // Check if next character is not part of right delimiter\n      const nextCharPos = end + rightLength;\n\n      if (\n        nextCharPos < content.length &&\n        right.includes(content.charAt(nextCharPos))\n      ) {\n        return false;\n      }\n    } else if (where === \"end\") {\n      // Check if content ends with right delimiter\n      start = content.lastIndexOf(left);\n\n      if (start === -1) {\n        return false;\n      }\n\n      end = content.indexOf(right, start + leftLength + 1);\n      start += leftLength;\n\n      if (end === -1 || end + rightLength !== content.length) {\n        return false;\n      }\n    } else {\n      // Check if content is wrapped by delimiters ('{.a}')\n      if (!content.startsWith(left) || !content.endsWith(right)) return false;\n\n      start = leftLength;\n      end = content.length - rightLength;\n    }\n\n    // Check if content between delimiters is valid\n    const firstCharCode = content.charCodeAt(start);\n    const length = end - start;\n\n    const isValid =\n      firstCharCode === CLASS_MARKER || firstCharCode === ID_MARKER\n        ? length >= 2\n        : length >= 1;\n\n    if (!isValid) return false;\n\n    return [start, end];\n  };\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nexport const getMatchingOpeningToken = (\n  tokens: Token[],\n  index: number,\n): Token | null => {\n  const token = tokens[index];\n\n  if (token.type === \"softbreak\") return null;\n\n  // non closing blocks, example img\n  if (token.nesting === 0) return token;\n\n  const level = token.level;\n  const type = token.type.replace(\"_close\", \"_open\");\n\n  while (index >= 0) {\n    const currentToken = tokens[index];\n\n    if (currentToken.type === type && currentToken.level === level)\n      return currentToken;\n\n    index--;\n  }\n\n  /* istanbul ignore next -- @preserve */\n  return null;\n};\n","/**\n * Get index item of array. Supports negative index, where -1 is last element in array.\n *\n * 获取数组中的索引项。支持负索引，其中 -1 是数组的最后一个元素。\n *\n * @param arr - Array to get item from / 要获取项的数组\n * @param index - Index of item / 项的索引\n * @returns Array item / 数组项\n */\nexport const getArrayItem = <T>(arr: T[], index: number): T =>\n  index >= 0 ? arr[index] : arr[arr.length + index];\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRuleSet } from \"../rules/types.js\";\nimport { getArrayItem } from \"../utils.js\";\n\nexport interface TestRuleResult {\n  /** whether rule matches token stream */\n  match: boolean;\n  /** position of token */\n  position: null | number;\n  range: [start: number, end: number] | null;\n}\n\n/**\n * Test if rule matches token stream.\n *\n */\nexport const testRule = (\n  tokens: Token[],\n  index: number,\n  rule: AttrRuleSet,\n): TestRuleResult => {\n  const testResult: TestRuleResult = {\n    match: false,\n    position: null,\n    range: null,\n  };\n  const isShift = rule.shift !== undefined;\n\n  const tokenIndex = isShift ? index + rule.shift : rule.position;\n\n  // we should never shift to negative indexes (rolling around to back of array)\n  if (isShift && tokenIndex < 0) return testResult;\n\n  const token = getArrayItem(tokens, tokenIndex);\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!token) return testResult;\n\n  for (const key of Object.keys(rule) as (keyof typeof rule)[]) {\n    if (key === \"shift\" || key === \"position\") continue;\n\n    if (token[key as keyof Token] == undefined) return testResult;\n\n    if (key === \"children\" && Array.isArray(rule.children)) {\n      if (!token.children?.length) return testResult;\n\n      const childTests = rule.children;\n      const children = token.children;\n      let match;\n      let range: [start: number, end: number] | null = null;\n\n      if (childTests.every((childTest) => childTest.position != undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every((childTest) => {\n          const result = testRule(children, childTest.position, childTest);\n\n          if (!result.match) return false;\n\n          if (result.range) range = result.range;\n\n          return true;\n        });\n\n        if (match) {\n          // get position of child\n          const { position } = childTests[childTests.length - 1];\n\n          testResult.position =\n            position >= 0 ? position : children.length + position;\n\n          // set pos data\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          testResult.range = range!;\n        }\n      } else {\n        for (let childIndex = 0; childIndex < children.length; childIndex++) {\n          match = childTests.every((childTest) => {\n            const result = testRule(children, childIndex, childTest);\n\n            if (!result.match) return false;\n\n            if (result.range) range = result.range;\n\n            return true;\n          });\n\n          if (match) {\n            testResult.position = childIndex;\n            // set pos data\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (range) testResult.range = range;\n            // all tests passes. so the check is successful\n            break;\n          }\n        }\n      }\n\n      if (match === false) return testResult;\n\n      continue;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const ruleDetail = rule[key];\n\n    switch (typeof ruleDetail) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\": {\n        if (token[key] !== ruleDetail) return testResult;\n\n        break;\n      }\n\n      case \"function\": {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const result = ruleDetail(token[key]) as\n          | boolean\n          | [start: number, end: number];\n\n        if (!result) return testResult;\n\n        if (Array.isArray(result)) testResult.range = result;\n\n        break;\n      }\n\n      // fall through for objects !== arrays of functions\n      default: {\n        throw new Error(\n          `Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string or function.`,\n        );\n      }\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  testResult.match = true;\n\n  return testResult;\n};\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getBlockRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * end of {.block}\n   */\n  ({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find the closing token by skipping all nested closing tokens\n      let closingTokenIndex = index + 1;\n\n      while (tokens[closingTokenIndex + 1]?.nesting === -1) {\n        closingTokenIndex++;\n      }\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, closingTokenIndex);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getFenceRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * fenced code blocks\n   *\n   * ```python {.cls}\n   * for i in range(10):\n   *     print(i)\n   * ```\n   */\n  ({\n    name: \"code-block\",\n    tests: [\n      {\n        shift: 0,\n        block: true,\n        info: getDelimiterChecker(options, \"end\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      const token = tokens[index];\n      const { info } = token;\n      const hasTrailingSpace = isSpace(info.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the current token\n      addAttrs(token, info, range, options.allowed);\n\n      // Remove the attribute syntax from info\n      token.info = info.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getHeadingRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * ## end of {#heading}\n   */\n  ({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: -1,\n        type: \"heading_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, index + 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getInlineRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * bla `click()`{.c} ![](img.png){.d}\n   *\n   * differs from 'inline attributes' as it does\n   * not have a closing tag (nesting: -1)\n   */\n  {\n    name: \"inline nesting self-close\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            type: (str) => str === \"image\" || str === \"code_inline\",\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n      const targetToken = childTokens[childIndex - 1];\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Apply attributes to the target token\n      addAttrs(targetToken, token.content, range, options.allowed);\n\n      if (token.content.length === attrsEndIndex) {\n        childTokens.splice(childIndex, 1);\n      } else {\n        token.content = token.content.slice(attrsEndIndex);\n      }\n    },\n  },\n\n  /**\n   * *emphasis*{.with attrs=1}\n   */\n  {\n    name: \"inline attributes\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            nesting: -1, // closing inline tag, </em>{.a}\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const currentToken = childTokens[childIndex];\n      const { content } = currentToken;\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Find the corresponding opening token\n      const openingToken = getMatchingOpeningToken(childTokens, childIndex - 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      currentToken.content = content.slice(attrsEndIndex);\n    },\n  },\n];\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getListRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * - item\n   * {.a}\n   */\n  {\n    name: \"list softbreak\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"only\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n\n      let listOpenIndex = index - 2;\n\n      // Find the list opening token\n      while (\n        tokens[listOpenIndex - 1] &&\n        tokens[listOpenIndex - 1].type !== \"ordered_list_open\" &&\n        tokens[listOpenIndex - 1].type !== \"bullet_list_open\"\n      ) {\n        listOpenIndex--;\n      }\n\n      // Apply attributes to the list opening token\n      addAttrs(\n        tokens[listOpenIndex - 1],\n        token.content,\n        range,\n        options.allowed,\n      );\n\n      // Remove the attribute tokens from children\n      tokens[index].children = childTokens.slice(0, -2);\n    },\n  },\n\n  /**\n   * - nested list\n   *   - with double \\n\n   *   {.a} <-- apply to nested ul\n   *\n   * {.b} <-- apply to root <ul>\n   */\n  {\n    name: \"list double softbreak\",\n    tests: [\n      {\n        // let this token be i = 0 so that we can erase\n        // the <p>{.a}</p> tokens below\n        shift: 0,\n        type: (type) =>\n          type === \"bullet_list_close\" || type === \"ordered_list_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n        children: (children) => children.length === 1,\n      },\n      {\n        shift: 3,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const openingToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  },\n\n  /**\n   * - end of {.list-item}\n   */\n  {\n    name: \"list item end\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrStartIndex = range[0] - options.left.length;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the list item opening token\n      addAttrs(tokens[index - 2], content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  },\n];\n","import type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getSoftBreakRule = (options: DelimiterConfig): AttrRule => ({\n  /**\n   * something with softbreak\n   * {.cls}\n   */\n\n  name: \"\\n{.a} softbreak then curly in start\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -2,\n          type: \"softbreak\",\n        },\n        {\n          position: -1,\n          type: \"text\",\n          content: getDelimiterChecker(options, \"only\"),\n        },\n      ],\n    },\n  ],\n  transform: (tokens, index, childIndex, range): void => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const childTokens = tokens[index].children!;\n    const token = childTokens[childIndex];\n\n    // Find the last closing tag by searching forward\n    let closingTokenIndex = index + 1;\n\n    while (\n      tokens[closingTokenIndex + 1] &&\n      tokens[closingTokenIndex + 1].nesting === -1\n    ) {\n      closingTokenIndex++;\n    }\n\n    // Apply attributes to the opening token\n    addAttrs(\n      getMatchingOpeningToken(tokens, closingTokenIndex),\n      token.content,\n      range,\n      options.allowed,\n    );\n\n    // Remove the softbreak and attribute tokens\n    tokens[index].children = childTokens.slice(0, -2);\n  },\n});\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule, DelimiterRange } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getHrRule = (options: DelimiterConfig): AttrRule => ({\n  /**\n   * horizontal rule --- {#id}\n   */\n  name: \"horizontal rule\",\n  tests: [\n    {\n      shift: 0,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 1,\n      type: \"inline\",\n      children: (children) => children.length === 1,\n      content: (content): DelimiterRange | false => {\n        let pos = 0;\n        let charCode;\n        const markerCode = content.charCodeAt(pos++);\n\n        if (\n          markerCode !== 45 /** - */ &&\n          markerCode !== 42 /** * */ &&\n          markerCode !== 95 /** _ */\n        )\n          return false;\n\n        let count = 1;\n\n        while (pos < content.length) {\n          charCode = content.charCodeAt(pos++);\n          if (charCode !== markerCode) break;\n          count++;\n        }\n\n        if (count < 3) return false;\n\n        if (!isSpace(content.charCodeAt(pos - 1))) pos--;\n\n        return getDelimiterChecker(options, \"end\")(content);\n      },\n    },\n    {\n      shift: 2,\n      type: \"paragraph_close\",\n    },\n  ],\n  transform: (tokens, index, _, range): void => {\n    const token = tokens[index];\n    // Extract attributes from the inline content\n    const inlineToken = tokens[index + 1];\n    const { content } = inlineToken;\n\n    token.type = \"hr\";\n    token.tag = \"hr\";\n    token.nesting = 0;\n\n    // Apply attributes to the hr token\n    addAttrs(token, content, range, options.allowed);\n    token.markup = content;\n\n    // Remove the inline and closing paragraph tokens\n    tokens.splice(index + 1, 2);\n  },\n});\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\ninterface TokenWithColumnCount extends Token {\n  meta:\n    | {\n        columnCount?: number;\n        [key: string]: unknown;\n      }\n    | undefined;\n}\n\n/**\n * Hidden table's cells and them inline children,\n * specially cast inline's content as empty\n * to prevent that escapes the table's box model\n */\nconst hideTokenContent = (token: Token): void => {\n  token.hidden = true;\n  token.children?.forEach((childToken) => {\n    childToken.content = \"\";\n    hideTokenContent(childToken);\n  });\n};\n\n/**\n * Handle rowspan logic for table cells\n */\nconst handleRowspan = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n  columnCount: number,\n  colspan: number,\n  rowspan: number,\n): void => {\n  let adjustedColumnCount = columnCount - (colspan > 0 ? colspan : 1);\n\n  for (\n    let tokenIndex = startIndex, remainingRows = rowspan;\n    tokenIndex < endIndex && remainingRows > 1;\n    tokenIndex++\n  ) {\n    if (tokens[tokenIndex].type === \"tr_open\") {\n      const trOpenToken = tokens[tokenIndex] as TokenWithColumnCount;\n\n      trOpenToken.meta ??= {};\n\n      if (trOpenToken.meta.columnCount) adjustedColumnCount -= 1;\n      trOpenToken.meta.columnCount = adjustedColumnCount;\n      remainingRows--;\n    }\n  }\n};\n\n/**\n * Handle table row processing\n */\nconst handleTableRow = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n): void => {\n  const token = tokens[startIndex] as TokenWithColumnCount;\n  const expectedColumnCount = token.meta?.columnCount;\n\n  if (!expectedColumnCount) return;\n\n  // hide extra table cells in the row\n  for (let index = startIndex, cellCount = 0; index < endIndex; index++) {\n    const currentToken = tokens[index];\n\n    // break at end of table row\n    if (currentToken.type === \"tr_close\") break;\n\n    // Count table cells in the row\n    if (currentToken.type === \"td_open\") cellCount += 1;\n\n    // hide extra table cells\n    if (cellCount > expectedColumnCount && !currentToken.hidden) {\n      hideTokenContent(currentToken);\n    }\n  }\n};\n\n/**\n * Handle colspan logic for table cells\n */\nconst handleColspan = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n  columnCount: number,\n  colspan: number,\n  tbodyOpenIndex: number,\n): void => {\n  const cellIndices: number[] = [];\n  const startToken = tokens[startIndex];\n\n  let end = startIndex + 3;\n  let colspanNum = columnCount;\n\n  // Find previous row children indices\n  for (let tokenIndex = startIndex; tokenIndex > tbodyOpenIndex; tokenIndex--) {\n    if (tokens[tokenIndex].type === \"tr_open\") {\n      colspanNum =\n        (tokens[tokenIndex] as TokenWithColumnCount).meta?.columnCount ??\n        colspanNum;\n      break;\n    } else if (tokens[tokenIndex].type === \"td_open\") {\n      cellIndices.unshift(tokenIndex);\n    }\n  }\n\n  // Find current row children indices\n  for (let index = startIndex + 2; index < endIndex; index++) {\n    if (tokens[index].type === \"tr_close\") {\n      end = index;\n      break;\n    } else if (tokens[index].type === \"td_open\") {\n      cellIndices.push(index);\n    }\n  }\n\n  const cellOffset = cellIndices.indexOf(startIndex);\n\n  const realColspan = Math.min(colspan, colspanNum - cellOffset);\n\n  if (colspan > realColspan) {\n    startToken.attrSet(\"colspan\", realColspan.toString());\n  }\n\n  const hiddenStartIndex = cellIndices.slice(\n    colspanNum + 1 - columnCount - realColspan,\n  )[0];\n\n  for (let index = hiddenStartIndex; index < end; index++) {\n    if (!tokens[index].hidden) hideTokenContent(tokens[index]);\n  }\n};\n\nexport const getTableRules = (options: DelimiterConfig): AttrRule[] => [\n  {\n    /**\n     * | h1 |\n     * | -- |\n     * | c1 |\n     *\n     * {.c}\n     */\n    name: \"table\",\n    tests: [\n      {\n        // let this token be i, such that for-loop continues at\n        // next token after tokens.splice\n        shift: 0,\n        type: \"table_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const tableOpeningToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the table opening token\n      addAttrs(tableOpeningToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  },\n  /**\n   * Handle table cell attributes: title {.class}\n   * This rule processes attributes within table cell text content\n   */\n  {\n    name: \"table cell attributes\",\n    tests: [\n      {\n        shift: -1,\n        type: (type) => type === \"td_open\" || type === \"th_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const cellOpenToken = tokens[index - 1];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find last attribute syntax in the content\n\n      // Apply attributes to the table cell token\n      addAttrs(cellOpenToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  },\n  {\n    /**\n     * | A | B |\n     * | -- | -- |\n     * | 1 | 2 |\n     *\n     * | C | D |\n     * | -- | -- |\n     *\n     * only `| A | B |` sets the columnCount metadata\n     */\n    name: \"table thead metadata\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tr_close\",\n      },\n      {\n        shift: 1,\n        type: \"thead_close\",\n      },\n      {\n        shift: 2,\n        type: \"tbody_open\",\n      },\n    ],\n\n    transform: (tokens, index): void => {\n      const trOpenToken = getMatchingOpeningToken(tokens, index);\n      const thCloseToken = tokens[index - 1];\n      let columnCount = 0;\n      let currentIndex = index - 1;\n\n      // Find the matching tr_open token and count columns\n      while (currentIndex > 0) {\n        const currentToken = tokens[currentIndex];\n\n        if (currentToken === trOpenToken) {\n          const tHeadOpenToken = tokens[\n            currentIndex - 1\n          ] as TokenWithColumnCount;\n\n          tHeadOpenToken.meta = {\n            ...tHeadOpenToken.meta,\n            columnCount,\n          };\n          break;\n        }\n\n        // Count th_close tokens at the same level\n        if (\n          currentToken.level === thCloseToken.level &&\n          currentToken.type === thCloseToken.type\n        ) {\n          columnCount++;\n        }\n\n        currentIndex--;\n      }\n\n      // Apply metadata to tbody_open token\n      const tbodyOpenToken = tokens[index + 2] as TokenWithColumnCount;\n\n      tbodyOpenToken.meta = {\n        ...tbodyOpenToken.meta,\n        columnCount,\n      };\n    },\n  },\n  {\n    /**\n     * | A | B | C | D |\n     * | -- | -- | -- | -- |\n     * | 1 | 11 | 111 | 1111 {rowspan=3} |\n     * | 2 {colspan=2 rowspan=2} | 22 | 222 | 2222 |\n     * | 3 | 33 | 333 | 3333 |\n     */\n    name: \"table tbody calculate\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tbody_close\",\n        hidden: false,\n      },\n    ],\n    transform: (tokens, index): void => {\n      // Find the tbody_open token index\n      let tbodyOpenIndex = index - 2;\n\n      while (tbodyOpenIndex > 0) {\n        tbodyOpenIndex--;\n        if (tokens[tbodyOpenIndex].type === \"tbody_open\") break;\n      }\n\n      const columnCount = Number(\n        (tokens[tbodyOpenIndex] as TokenWithColumnCount).meta?.columnCount ?? 0,\n      );\n\n      if (columnCount < 2) return;\n\n      const maxLevel = tokens[index].level + 2;\n\n      for (\n        let currentIndex = tbodyOpenIndex;\n        currentIndex < index;\n        currentIndex++\n      ) {\n        if (tokens[currentIndex].level > maxLevel) continue;\n\n        const token = tokens[currentIndex];\n        const rowspan = token.hidden ? 0 : Number(token.attrGet(\"rowspan\"));\n        const colspan = token.hidden ? 0 : Number(token.attrGet(\"colspan\"));\n\n        if (rowspan > 1) {\n          handleRowspan(\n            tokens,\n            currentIndex,\n            index,\n            columnCount,\n            colspan,\n            rowspan,\n          );\n        }\n\n        if (token.type === \"tr_open\") {\n          handleTableRow(tokens, currentIndex, index);\n        }\n\n        if (colspan > 1) {\n          handleColspan(\n            tokens,\n            currentIndex,\n            index,\n            columnCount,\n            colspan,\n            tbodyOpenIndex,\n          );\n        }\n      }\n    },\n  },\n];\n","import type { AttrRule } from \"./types.js\";\nimport type {\n  MarkdownItAttrRuleName,\n  MarkdownItAttrsOptions,\n} from \"../options.js\";\nimport { getBlockRule } from \"./block.js\";\nimport { getFenceRule } from \"./fence.js\";\nimport { getHeadingRule } from \"./heading.js\";\nimport { getHrRule } from \"./hr.js\";\nimport { getInlineRules } from \"./inline.js\";\nimport { getListRules } from \"./list.js\";\nimport { getSoftBreakRule } from \"./softbreak.js\";\nimport { getTableRules } from \"./table.js\";\n\nconst AVAILABLE_RULES: MarkdownItAttrRuleName[] = [\n  \"fence\",\n  \"inline\",\n  \"table\",\n  \"list\",\n  \"heading\",\n  \"hr\",\n  \"softbreak\",\n  \"block\",\n];\n\nexport const getRules = (\n  options: Required<MarkdownItAttrsOptions>,\n): AttrRule[] => {\n  const enabledRules =\n    // disable\n    options.rule === false\n      ? []\n      : Array.isArray(options.rule)\n        ? // user specific rules\n          options.rule.filter((item) => AVAILABLE_RULES.includes(item))\n        : AVAILABLE_RULES;\n\n  const rules: AttrRule[] = [];\n\n  if (enabledRules.includes(\"fence\")) rules.push(getFenceRule(options));\n  if (enabledRules.includes(\"inline\")) rules.push(...getInlineRules(options));\n  if (enabledRules.includes(\"table\")) rules.push(...getTableRules(options));\n  if (enabledRules.includes(\"list\")) rules.push(...getListRules(options));\n  if (enabledRules.includes(\"softbreak\")) rules.push(getSoftBreakRule(options));\n  if (enabledRules.includes(\"hr\")) rules.push(getHrRule(options));\n  if (enabledRules.includes(\"block\")) rules.push(getBlockRule(options));\n  // heading rule is fully covered by block rules\n  else if (enabledRules.includes(\"heading\"))\n    rules.push(getHeadingRule(options));\n\n  return rules;\n};\n","/**\n * Forked and modified from https://github.com/arve0/markdown-it-attrs/\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleCore } from \"markdown-it/lib/parser_core.mjs\";\n\nimport { testRule } from \"./helper/index.js\";\nimport type { MarkdownItAttrsOptions } from \"./options.js\";\nimport type { DelimiterRange } from \"./rules/index.js\";\nimport { getRules } from \"./rules/index.js\";\n\nexport const attrs: PluginWithOptions<MarkdownItAttrsOptions> = (\n  md,\n  { left = \"{\", right = \"}\", allowed = [], rule = \"all\" } = {},\n) => {\n  const rules = getRules({\n    left,\n    right,\n    allowed,\n    rule,\n  });\n\n  const attrsRule: RuleCore = ({ tokens }) => {\n    for (let index = 0; index < tokens.length; index++)\n      for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n        const pattern = rules[ruleIndex];\n        // position of child with offset 0\n        let position: null | number = null;\n        let range: DelimiterRange | null = null;\n\n        const match = pattern.tests.every((test) => {\n          const result = testRule(tokens, index, test);\n\n          if (result.position !== null) ({ position } = result);\n          if (result.range) range = result.range;\n\n          return result.match;\n        });\n\n        if (match) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          pattern.transform(tokens, index, position!, range!);\n\n          if (\n            pattern.name === \"inline attributes\" ||\n            pattern.name === \"inline nesting self-close\"\n          )\n            // retry, may be several inline attributes\n            ruleIndex--;\n        }\n      }\n  };\n\n  md.core.ruler.before(\"linkify\", \"attrs\", attrsRule);\n};\n"],"names":["CLASS_MARKER","ID_MARKER","PAIR_SEPARATOR","KEY_SEPARATOR","QUOTE_MARKER","isAllowedKeyChar","charCode","getAttrs","str","range","allowed","key","value","parsingKey","valueInsideQuotes","attrs","index","attr","item","addAttrs","token","content","getDelimiterChecker","left","right","where","leftLength","rightLength","minContentLength","start","end","nextCharPos","firstCharCode","length","getMatchingOpeningToken","tokens","level","type","currentToken","getArrayItem","arr","testRule","rule","testResult","isShift","tokenIndex","childTests","children","match","childTest","result","position","childIndex","ruleDetail","getBlockRule","options","attrStartIndex","hasTrailingSpace","isSpace","closingTokenIndex","openingToken","getFenceRule","_","info","getHeadingRule","getInlineRules","childTokens","targetToken","attrsEndIndex","getListRules","listOpenIndex","getSoftBreakRule","getHrRule","pos","markerCode","count","inlineToken","hideTokenContent","childToken","handleRowspan","startIndex","endIndex","columnCount","colspan","rowspan","adjustedColumnCount","remainingRows","trOpenToken","handleTableRow","expectedColumnCount","cellCount","handleColspan","tbodyOpenIndex","cellIndices","startToken","colspanNum","cellOffset","realColspan","hiddenStartIndex","getTableRules","tableOpeningToken","cellOpenToken","thCloseToken","currentIndex","tHeadOpenToken","tbodyOpenToken","maxLevel","AVAILABLE_RULES","getRules","enabledRules","rules","md","attrsRule","ruleIndex","pattern","test"],"mappings":"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"}