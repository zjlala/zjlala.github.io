{"version":3,"file":"browser.js","sources":["../src/helper/constants.ts","../src/helper/getAttrs.ts","../src/helper/addAttrs.ts","../src/helper/getDelimiterChecker.ts","../src/helper/getMatchingOpeningToken.ts","../src/utils.ts","../src/helper/testRule.ts","../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs","../src/rules/block.ts","../src/rules/fence.ts","../src/rules/heading.ts","../src/rules/inline.ts","../src/rules/list.ts","../src/rules/softbreak.ts","../src/rules/hr.ts","../src/rules/table.ts","../src/rules/rules.ts","../src/plugin.ts"],"sourcesContent":["/** . */\nexport const CLASS_MARKER = 46;\n/** # */\nexport const ID_MARKER = 35;\n/** space */\nexport const PAIR_SEPARATOR = 32;\n/** = */\nexport const KEY_SEPARATOR = 61;\n/** \" */\nexport const QUOTE_MARKER = 34;\n","import {\n  CLASS_MARKER,\n  ID_MARKER,\n  KEY_SEPARATOR,\n  PAIR_SEPARATOR,\n  QUOTE_MARKER,\n} from \"./constants.js\";\nimport type { Attr } from \"./types.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nconst isAllowedKeyChar = (charCode: number): boolean =>\n  !(\n    charCode === 9 /* \\t */ ||\n    charCode === 10 /* \\n */ ||\n    charCode === 12 /* \\f */ ||\n    charCode === 32 /* 空格 */ ||\n    charCode === 47 /* / */ ||\n    charCode === 62 /* > */ ||\n    charCode === 34 /* \" */ ||\n    charCode === 39 /* ' */ ||\n    charCode === 61 /* = */\n  );\n\nexport const getAttrs = (\n  str: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): Attr[] => {\n  let key = \"\";\n  let value = \"\";\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  const attrs: Attr[] = [];\n\n  // read inside marker\n  // start + left delimiter length to avoid beginning marker\n  // breaks when ending marker is found or end of string\n  for (let index = range[0]; index < range[1]; index++) {\n    const charCode = str.charCodeAt(index);\n\n    // switch to reading value if equal sign\n    if (charCode === KEY_SEPARATOR && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (charCode === CLASS_MARKER && key === \"\") {\n      if (str.charCodeAt(index + 1) === CLASS_MARKER) {\n        key = \"css-module\";\n        index++;\n      } else {\n        key = \"class\";\n      }\n\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (charCode === ID_MARKER && key === \"\") {\n      key = \"id\";\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (charCode === QUOTE_MARKER && value === \"\" && !valueInsideQuotes) {\n      valueInsideQuotes = true;\n      continue;\n    }\n\n    if (charCode === QUOTE_MARKER && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if (charCode === PAIR_SEPARATOR && !valueInsideQuotes) {\n      if (key === \"\")\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n\n      attrs.push([key, value]);\n      key = \"\";\n      value = \"\";\n      parsingKey = true;\n\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && !isAllowedKeyChar(charCode)) continue;\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += String.fromCharCode(charCode);\n      continue;\n    }\n\n    value += String.fromCharCode(charCode);\n  }\n\n  // append last key/value pair\n  if (key !== \"\") attrs.push([key, value]);\n\n  return allowed.length\n    ? attrs.filter(([attr]) =>\n        allowed.some((item) =>\n          item instanceof RegExp ? item.test(attr) : item === attr,\n        ),\n      )\n    : attrs;\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport { getAttrs } from \"./getAttrs.js\";\nimport type { DelimiterRange } from \"../rules/types.js\";\n\nexport const addAttrs = (\n  token: Token | null,\n  content: string,\n  range: DelimiterRange,\n  allowed: (string | RegExp)[],\n): void => {\n  if (!token) return;\n\n  getAttrs(content, range, allowed).forEach(([key, value]) => {\n    switch (key) {\n      case \"class\":\n        token.attrJoin(\"class\", value);\n        break;\n      case \"css-module\":\n        token.attrJoin(\"css-module\", value);\n        break;\n      default:\n        token.attrPush([key, value]);\n    }\n  });\n};\n","import { CLASS_MARKER, ID_MARKER } from \"./constants.js\";\nimport type { DelimiterConfig } from \"./types.js\";\nimport type { DelimiterChecker } from \"../rules/types.js\";\n\n/**\n * Get a function to check if a string matches the delimiter pattern\n * 获取一个函数来检查字符串是否匹配分隔符模式\n *\n * @param options - Delimiter configuration / 分隔符配置\n * @param where - Position for matching: start, end, or only / 匹配位置：开始、结束或仅匹配\n * @returns A function that checks if content matches the delimiter pattern / 检查内容是否匹配分隔符模式的函数\n */\nexport const getDelimiterChecker = (\n  { left, right }: DelimiterConfig,\n  where: \"start\" | \"end\" | \"only\",\n): DelimiterChecker => {\n  if (![\"start\", \"end\", \"only\"].includes(where)) {\n    throw new Error(\n      `Invalid 'where' parameter: ${where}. Expected 'start', 'end', or 'only'.`,\n    );\n  }\n\n  // Cache frequently used values\n  const leftLength = left.length;\n  const rightLength = right.length;\n  const minContentLength = leftLength + 1 + rightLength;\n\n  return (content) => {\n    // Quick check for minimum length requirements\n    if (typeof content !== \"string\" || content.length < minContentLength)\n      return false;\n\n    let start: number;\n    let end: number;\n\n    if (where === \"start\") {\n      // Check if content starts with left delimiter\n      if (!content.startsWith(left)) return false;\n\n      start = leftLength;\n      end = content.indexOf(right, leftLength + 1);\n\n      if (end === -1) return false;\n\n      // Check if next character is not part of right delimiter\n      const nextCharPos = end + rightLength;\n\n      if (\n        nextCharPos < content.length &&\n        right.includes(content.charAt(nextCharPos))\n      ) {\n        return false;\n      }\n    } else if (where === \"end\") {\n      // Check if content ends with right delimiter\n      start = content.lastIndexOf(left);\n\n      if (start === -1) {\n        return false;\n      }\n\n      end = content.indexOf(right, start + leftLength + 1);\n      start += leftLength;\n\n      if (end === -1 || end + rightLength !== content.length) {\n        return false;\n      }\n    } else {\n      // Check if content is wrapped by delimiters ('{.a}')\n      if (!content.startsWith(left) || !content.endsWith(right)) return false;\n\n      start = leftLength;\n      end = content.length - rightLength;\n    }\n\n    // Check if content between delimiters is valid\n    const firstCharCode = content.charCodeAt(start);\n    const length = end - start;\n\n    const isValid =\n      firstCharCode === CLASS_MARKER || firstCharCode === ID_MARKER\n        ? length >= 2\n        : length >= 1;\n\n    if (!isValid) return false;\n\n    return [start, end];\n  };\n};\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nexport const getMatchingOpeningToken = (\n  tokens: Token[],\n  index: number,\n): Token | null => {\n  const token = tokens[index];\n\n  if (token.type === \"softbreak\") return null;\n\n  // non closing blocks, example img\n  if (token.nesting === 0) return token;\n\n  const level = token.level;\n  const type = token.type.replace(\"_close\", \"_open\");\n\n  while (index >= 0) {\n    const currentToken = tokens[index];\n\n    if (currentToken.type === type && currentToken.level === level)\n      return currentToken;\n\n    index--;\n  }\n\n  /* istanbul ignore next -- @preserve */\n  return null;\n};\n","/**\n * Get index item of array. Supports negative index, where -1 is last element in array.\n *\n * 获取数组中的索引项。支持负索引，其中 -1 是数组的最后一个元素。\n *\n * @param arr - Array to get item from / 要获取项的数组\n * @param index - Index of item / 项的索引\n * @returns Array item / 数组项\n */\nexport const getArrayItem = <T>(arr: T[], index: number): T =>\n  index >= 0 ? arr[index] : arr[arr.length + index];\n","import type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRuleSet } from \"../rules/types.js\";\nimport { getArrayItem } from \"../utils.js\";\n\nexport interface TestRuleResult {\n  /** whether rule matches token stream */\n  match: boolean;\n  /** position of token */\n  position: null | number;\n  range: [start: number, end: number] | null;\n}\n\n/**\n * Test if rule matches token stream.\n *\n */\nexport const testRule = (\n  tokens: Token[],\n  index: number,\n  rule: AttrRuleSet,\n): TestRuleResult => {\n  const testResult: TestRuleResult = {\n    match: false,\n    position: null,\n    range: null,\n  };\n  const isShift = rule.shift !== undefined;\n\n  const tokenIndex = isShift ? index + rule.shift : rule.position;\n\n  // we should never shift to negative indexes (rolling around to back of array)\n  if (isShift && tokenIndex < 0) return testResult;\n\n  const token = getArrayItem(tokens, tokenIndex);\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!token) return testResult;\n\n  for (const key of Object.keys(rule) as (keyof typeof rule)[]) {\n    if (key === \"shift\" || key === \"position\") continue;\n\n    if (token[key as keyof Token] == undefined) return testResult;\n\n    if (key === \"children\" && Array.isArray(rule.children)) {\n      if (!token.children?.length) return testResult;\n\n      const childTests = rule.children;\n      const children = token.children;\n      let match;\n      let range: [start: number, end: number] | null = null;\n\n      if (childTests.every((childTest) => childTest.position != undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every((childTest) => {\n          const result = testRule(children, childTest.position, childTest);\n\n          if (!result.match) return false;\n\n          if (result.range) range = result.range;\n\n          return true;\n        });\n\n        if (match) {\n          // get position of child\n          const { position } = childTests[childTests.length - 1];\n\n          testResult.position =\n            position >= 0 ? position : children.length + position;\n\n          // set pos data\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          testResult.range = range!;\n        }\n      } else {\n        for (let childIndex = 0; childIndex < children.length; childIndex++) {\n          match = childTests.every((childTest) => {\n            const result = testRule(children, childIndex, childTest);\n\n            if (!result.match) return false;\n\n            if (result.range) range = result.range;\n\n            return true;\n          });\n\n          if (match) {\n            testResult.position = childIndex;\n            // set pos data\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (range) testResult.range = range;\n            // all tests passes. so the check is successful\n            break;\n          }\n        }\n      }\n\n      if (match === false) return testResult;\n\n      continue;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const ruleDetail = rule[key];\n\n    switch (typeof ruleDetail) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\": {\n        if (token[key] !== ruleDetail) return testResult;\n\n        break;\n      }\n\n      case \"function\": {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const result = ruleDetail(token[key]) as\n          | boolean\n          | [start: number, end: number];\n\n        if (!result) return testResult;\n\n        if (Array.isArray(result)) testResult.range = result;\n\n        break;\n      }\n\n      // fall through for objects !== arrays of functions\n      default: {\n        throw new Error(\n          `Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string or function.`,\n        );\n      }\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  testResult.match = true;\n\n  return testResult;\n};\n","// Utilities\n//\n\nimport * as mdurl from 'mdurl'\nimport * as ucmicro from 'uc.micro'\nimport { decodeHTML } from 'entities'\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = decodeHTML(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return ucmicro.P.test(ch) || ucmicro.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl, ucmicro }\n\nexport {\n  lib,\n  assign,\n  isString,\n  has,\n  unescapeMd,\n  unescapeAll,\n  isValidEntityCode,\n  fromCodePoint,\n  escapeHtml,\n  arrayReplaceAt,\n  isSpace,\n  isWhiteSpace,\n  isMdAsciiPunct,\n  isPunctChar,\n  escapeRE,\n  normalizeReference\n}\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getBlockRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * end of {.block}\n   */\n  ({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find the closing token by skipping all nested closing tokens\n      let closingTokenIndex = index + 1;\n\n      while (tokens[closingTokenIndex + 1]?.nesting === -1) {\n        closingTokenIndex++;\n      }\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, closingTokenIndex);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getFenceRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * fenced code blocks\n   *\n   * ```python {.cls}\n   * for i in range(10):\n   *     print(i)\n   * ```\n   */\n  ({\n    name: \"code-block\",\n    tests: [\n      {\n        shift: 0,\n        block: true,\n        info: getDelimiterChecker(options, \"end\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      const token = tokens[index];\n      const { info } = token;\n      const hasTrailingSpace = isSpace(info.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the current token\n      addAttrs(token, info, range, options.allowed);\n\n      // Remove the attribute syntax from info\n      token.info = info.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getHeadingRule = (options: DelimiterConfig): AttrRule =>\n  /**\n   * ## end of {#heading}\n   */\n  ({\n    name: \"end of block\",\n    tests: [\n      {\n        shift: -1,\n        type: \"heading_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            content: getDelimiterChecker(options, \"end\"),\n            type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Get the corresponding opening token\n      const openingToken = getMatchingOpeningToken(tokens, index + 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove the attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  });\n","import type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getInlineRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * bla `click()`{.c} ![](img.png){.d}\n   *\n   * differs from 'inline attributes' as it does\n   * not have a closing tag (nesting: -1)\n   */\n  {\n    name: \"inline nesting self-close\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            type: (str) => str === \"image\" || str === \"code_inline\",\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n      const targetToken = childTokens[childIndex - 1];\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Apply attributes to the target token\n      addAttrs(targetToken, token.content, range, options.allowed);\n\n      if (token.content.length === attrsEndIndex) {\n        childTokens.splice(childIndex, 1);\n      } else {\n        token.content = token.content.slice(attrsEndIndex);\n      }\n    },\n  },\n\n  /**\n   * *emphasis*{.with attrs=1}\n   */\n  {\n    name: \"inline attributes\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            nesting: -1, // closing inline tag, </em>{.a}\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"start\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const currentToken = childTokens[childIndex];\n      const { content } = currentToken;\n      const attrsEndIndex = options.right.length + range[1];\n\n      // Find the corresponding opening token\n      const openingToken = getMatchingOpeningToken(childTokens, childIndex - 1);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      currentToken.content = content.slice(attrsEndIndex);\n    },\n  },\n];\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getListRules = (options: DelimiterConfig): AttrRule[] => [\n  /**\n   * - item\n   * {.a}\n   */\n  {\n    name: \"list softbreak\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"only\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const childTokens = tokens[index].children!;\n      const token = childTokens[childIndex];\n\n      let listOpenIndex = index - 2;\n\n      // Find the list opening token\n      while (\n        tokens[listOpenIndex - 1] &&\n        tokens[listOpenIndex - 1].type !== \"ordered_list_open\" &&\n        tokens[listOpenIndex - 1].type !== \"bullet_list_open\"\n      ) {\n        listOpenIndex--;\n      }\n\n      // Apply attributes to the list opening token\n      addAttrs(\n        tokens[listOpenIndex - 1],\n        token.content,\n        range,\n        options.allowed,\n      );\n\n      // Remove the attribute tokens from children\n      tokens[index].children = childTokens.slice(0, -2);\n    },\n  },\n\n  /**\n   * - nested list\n   *   - with double \\n\n   *   {.a} <-- apply to nested ul\n   *\n   * {.b} <-- apply to root <ul>\n   */\n  {\n    name: \"list double softbreak\",\n    tests: [\n      {\n        // let this token be i = 0 so that we can erase\n        // the <p>{.a}</p> tokens below\n        shift: 0,\n        type: (type) =>\n          type === \"bullet_list_close\" || type === \"ordered_list_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n        children: (children) => children.length === 1,\n      },\n      {\n        shift: 3,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const openingToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the opening token\n      addAttrs(openingToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  },\n\n  /**\n   * - end of {.list-item}\n   */\n  {\n    name: \"list item end\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrStartIndex = range[0] - options.left.length;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Apply attributes to the list item opening token\n      addAttrs(tokens[index - 2], content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  },\n];\n","import type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\nexport const getSoftBreakRule = (options: DelimiterConfig): AttrRule => ({\n  /**\n   * something with softbreak\n   * {.cls}\n   */\n\n  name: \"\\n{.a} softbreak then curly in start\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -2,\n          type: \"softbreak\",\n        },\n        {\n          position: -1,\n          type: \"text\",\n          content: getDelimiterChecker(options, \"only\"),\n        },\n      ],\n    },\n  ],\n  transform: (tokens, index, childIndex, range): void => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const childTokens = tokens[index].children!;\n    const token = childTokens[childIndex];\n\n    // Find the last closing tag by searching forward\n    let closingTokenIndex = index + 1;\n\n    while (\n      tokens[closingTokenIndex + 1] &&\n      tokens[closingTokenIndex + 1].nesting === -1\n    ) {\n      closingTokenIndex++;\n    }\n\n    // Apply attributes to the opening token\n    addAttrs(\n      getMatchingOpeningToken(tokens, closingTokenIndex),\n      token.content,\n      range,\n      options.allowed,\n    );\n\n    // Remove the softbreak and attribute tokens\n    tokens[index].children = childTokens.slice(0, -2);\n  },\n});\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\n\nimport type { AttrRule, DelimiterRange } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport { addAttrs, getDelimiterChecker } from \"../helper/index.js\";\n\nexport const getHrRule = (options: DelimiterConfig): AttrRule => ({\n  /**\n   * horizontal rule --- {#id}\n   */\n  name: \"horizontal rule\",\n  tests: [\n    {\n      shift: 0,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 1,\n      type: \"inline\",\n      children: (children) => children.length === 1,\n      content: (content): DelimiterRange | false => {\n        let pos = 0;\n        let charCode;\n        const markerCode = content.charCodeAt(pos++);\n\n        if (\n          markerCode !== 45 /** - */ &&\n          markerCode !== 42 /** * */ &&\n          markerCode !== 95 /** _ */\n        )\n          return false;\n\n        let count = 1;\n\n        while (pos < content.length) {\n          charCode = content.charCodeAt(pos++);\n          if (charCode !== markerCode) break;\n          count++;\n        }\n\n        if (count < 3) return false;\n\n        if (!isSpace(content.charCodeAt(pos - 1))) pos--;\n\n        return getDelimiterChecker(options, \"end\")(content);\n      },\n    },\n    {\n      shift: 2,\n      type: \"paragraph_close\",\n    },\n  ],\n  transform: (tokens, index, _, range): void => {\n    const token = tokens[index];\n    // Extract attributes from the inline content\n    const inlineToken = tokens[index + 1];\n    const { content } = inlineToken;\n\n    token.type = \"hr\";\n    token.tag = \"hr\";\n    token.nesting = 0;\n\n    // Apply attributes to the hr token\n    addAttrs(token, content, range, options.allowed);\n    token.markup = content;\n\n    // Remove the inline and closing paragraph tokens\n    tokens.splice(index + 1, 2);\n  },\n});\n","import { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { AttrRule } from \"./types.js\";\nimport type { DelimiterConfig } from \"../helper/index.js\";\nimport {\n  addAttrs,\n  getDelimiterChecker,\n  getMatchingOpeningToken,\n} from \"../helper/index.js\";\n\ninterface TokenWithColumnCount extends Token {\n  meta:\n    | {\n        columnCount?: number;\n        [key: string]: unknown;\n      }\n    | undefined;\n}\n\n/**\n * Hidden table's cells and them inline children,\n * specially cast inline's content as empty\n * to prevent that escapes the table's box model\n */\nconst hideTokenContent = (token: Token): void => {\n  token.hidden = true;\n  token.children?.forEach((childToken) => {\n    childToken.content = \"\";\n    hideTokenContent(childToken);\n  });\n};\n\n/**\n * Handle rowspan logic for table cells\n */\nconst handleRowspan = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n  columnCount: number,\n  colspan: number,\n  rowspan: number,\n): void => {\n  let adjustedColumnCount = columnCount - (colspan > 0 ? colspan : 1);\n\n  for (\n    let tokenIndex = startIndex, remainingRows = rowspan;\n    tokenIndex < endIndex && remainingRows > 1;\n    tokenIndex++\n  ) {\n    if (tokens[tokenIndex].type === \"tr_open\") {\n      const trOpenToken = tokens[tokenIndex] as TokenWithColumnCount;\n\n      trOpenToken.meta ??= {};\n\n      if (trOpenToken.meta.columnCount) adjustedColumnCount -= 1;\n      trOpenToken.meta.columnCount = adjustedColumnCount;\n      remainingRows--;\n    }\n  }\n};\n\n/**\n * Handle table row processing\n */\nconst handleTableRow = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n): void => {\n  const token = tokens[startIndex] as TokenWithColumnCount;\n  const expectedColumnCount = token.meta?.columnCount;\n\n  if (!expectedColumnCount) return;\n\n  // hide extra table cells in the row\n  for (let index = startIndex, cellCount = 0; index < endIndex; index++) {\n    const currentToken = tokens[index];\n\n    // break at end of table row\n    if (currentToken.type === \"tr_close\") break;\n\n    // Count table cells in the row\n    if (currentToken.type === \"td_open\") cellCount += 1;\n\n    // hide extra table cells\n    if (cellCount > expectedColumnCount && !currentToken.hidden) {\n      hideTokenContent(currentToken);\n    }\n  }\n};\n\n/**\n * Handle colspan logic for table cells\n */\nconst handleColspan = (\n  tokens: Token[],\n  startIndex: number,\n  endIndex: number,\n  columnCount: number,\n  colspan: number,\n  tbodyOpenIndex: number,\n): void => {\n  const cellIndices: number[] = [];\n  const startToken = tokens[startIndex];\n\n  let end = startIndex + 3;\n  let colspanNum = columnCount;\n\n  // Find previous row children indices\n  for (let tokenIndex = startIndex; tokenIndex > tbodyOpenIndex; tokenIndex--) {\n    if (tokens[tokenIndex].type === \"tr_open\") {\n      colspanNum =\n        (tokens[tokenIndex] as TokenWithColumnCount).meta?.columnCount ??\n        colspanNum;\n      break;\n    } else if (tokens[tokenIndex].type === \"td_open\") {\n      cellIndices.unshift(tokenIndex);\n    }\n  }\n\n  // Find current row children indices\n  for (let index = startIndex + 2; index < endIndex; index++) {\n    if (tokens[index].type === \"tr_close\") {\n      end = index;\n      break;\n    } else if (tokens[index].type === \"td_open\") {\n      cellIndices.push(index);\n    }\n  }\n\n  const cellOffset = cellIndices.indexOf(startIndex);\n\n  const realColspan = Math.min(colspan, colspanNum - cellOffset);\n\n  if (colspan > realColspan) {\n    startToken.attrSet(\"colspan\", realColspan.toString());\n  }\n\n  const hiddenStartIndex = cellIndices.slice(\n    colspanNum + 1 - columnCount - realColspan,\n  )[0];\n\n  for (let index = hiddenStartIndex; index < end; index++) {\n    if (!tokens[index].hidden) hideTokenContent(tokens[index]);\n  }\n};\n\nexport const getTableRules = (options: DelimiterConfig): AttrRule[] => [\n  {\n    /**\n     * | h1 |\n     * | -- |\n     * | c1 |\n     *\n     * {.c}\n     */\n    name: \"table\",\n    tests: [\n      {\n        // let this token be i, such that for-loop continues at\n        // next token after tokens.splice\n        shift: 0,\n        type: \"table_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: getDelimiterChecker(options, \"only\"),\n      },\n    ],\n    transform: (tokens, index, _, range): void => {\n      const token = tokens[index + 2];\n      const tableOpeningToken = getMatchingOpeningToken(tokens, index);\n\n      // Apply attributes to the table opening token\n      addAttrs(tableOpeningToken, token.content, range, options.allowed);\n\n      // Remove the paragraph tokens containing the attributes\n      tokens.splice(index + 1, 3);\n    },\n  },\n  /**\n   * Handle table cell attributes: title {.class}\n   * This rule processes attributes within table cell text content\n   */\n  {\n    name: \"table cell attributes\",\n    tests: [\n      {\n        shift: -1,\n        type: (type) => type === \"td_open\" || type === \"th_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: 0,\n            type: \"text\",\n            content: getDelimiterChecker(options, \"end\"),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex, range): void => {\n      const attrStartIndex = range[0] - options.left.length;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const token = tokens[index].children![childIndex];\n      const cellOpenToken = tokens[index - 1];\n      const { content } = token;\n      const hasTrailingSpace = isSpace(content.charCodeAt(attrStartIndex - 1));\n\n      // Find last attribute syntax in the content\n\n      // Apply attributes to the table cell token\n      addAttrs(cellOpenToken, content, range, options.allowed);\n\n      // Remove attribute syntax from content\n      token.content = content.slice(\n        0,\n        hasTrailingSpace ? attrStartIndex - 1 : attrStartIndex,\n      );\n    },\n  },\n  {\n    /**\n     * | A | B |\n     * | -- | -- |\n     * | 1 | 2 |\n     *\n     * | C | D |\n     * | -- | -- |\n     *\n     * only `| A | B |` sets the columnCount metadata\n     */\n    name: \"table thead metadata\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tr_close\",\n      },\n      {\n        shift: 1,\n        type: \"thead_close\",\n      },\n      {\n        shift: 2,\n        type: \"tbody_open\",\n      },\n    ],\n\n    transform: (tokens, index): void => {\n      const trOpenToken = getMatchingOpeningToken(tokens, index);\n      const thCloseToken = tokens[index - 1];\n      let columnCount = 0;\n      let currentIndex = index - 1;\n\n      // Find the matching tr_open token and count columns\n      while (currentIndex > 0) {\n        const currentToken = tokens[currentIndex];\n\n        if (currentToken === trOpenToken) {\n          const tHeadOpenToken = tokens[\n            currentIndex - 1\n          ] as TokenWithColumnCount;\n\n          tHeadOpenToken.meta = {\n            ...tHeadOpenToken.meta,\n            columnCount,\n          };\n          break;\n        }\n\n        // Count th_close tokens at the same level\n        if (\n          currentToken.level === thCloseToken.level &&\n          currentToken.type === thCloseToken.type\n        ) {\n          columnCount++;\n        }\n\n        currentIndex--;\n      }\n\n      // Apply metadata to tbody_open token\n      const tbodyOpenToken = tokens[index + 2] as TokenWithColumnCount;\n\n      tbodyOpenToken.meta = {\n        ...tbodyOpenToken.meta,\n        columnCount,\n      };\n    },\n  },\n  {\n    /**\n     * | A | B | C | D |\n     * | -- | -- | -- | -- |\n     * | 1 | 11 | 111 | 1111 {rowspan=3} |\n     * | 2 {colspan=2 rowspan=2} | 22 | 222 | 2222 |\n     * | 3 | 33 | 333 | 3333 |\n     */\n    name: \"table tbody calculate\",\n    tests: [\n      {\n        shift: 0,\n        type: \"tbody_close\",\n        hidden: false,\n      },\n    ],\n    transform: (tokens, index): void => {\n      // Find the tbody_open token index\n      let tbodyOpenIndex = index - 2;\n\n      while (tbodyOpenIndex > 0) {\n        tbodyOpenIndex--;\n        if (tokens[tbodyOpenIndex].type === \"tbody_open\") break;\n      }\n\n      const columnCount = Number(\n        (tokens[tbodyOpenIndex] as TokenWithColumnCount).meta?.columnCount ?? 0,\n      );\n\n      if (columnCount < 2) return;\n\n      const maxLevel = tokens[index].level + 2;\n\n      for (\n        let currentIndex = tbodyOpenIndex;\n        currentIndex < index;\n        currentIndex++\n      ) {\n        if (tokens[currentIndex].level > maxLevel) continue;\n\n        const token = tokens[currentIndex];\n        const rowspan = token.hidden ? 0 : Number(token.attrGet(\"rowspan\"));\n        const colspan = token.hidden ? 0 : Number(token.attrGet(\"colspan\"));\n\n        if (rowspan > 1) {\n          handleRowspan(\n            tokens,\n            currentIndex,\n            index,\n            columnCount,\n            colspan,\n            rowspan,\n          );\n        }\n\n        if (token.type === \"tr_open\") {\n          handleTableRow(tokens, currentIndex, index);\n        }\n\n        if (colspan > 1) {\n          handleColspan(\n            tokens,\n            currentIndex,\n            index,\n            columnCount,\n            colspan,\n            tbodyOpenIndex,\n          );\n        }\n      }\n    },\n  },\n];\n","import type { AttrRule } from \"./types.js\";\nimport type {\n  MarkdownItAttrRuleName,\n  MarkdownItAttrsOptions,\n} from \"../options.js\";\nimport { getBlockRule } from \"./block.js\";\nimport { getFenceRule } from \"./fence.js\";\nimport { getHeadingRule } from \"./heading.js\";\nimport { getHrRule } from \"./hr.js\";\nimport { getInlineRules } from \"./inline.js\";\nimport { getListRules } from \"./list.js\";\nimport { getSoftBreakRule } from \"./softbreak.js\";\nimport { getTableRules } from \"./table.js\";\n\nconst AVAILABLE_RULES: MarkdownItAttrRuleName[] = [\n  \"fence\",\n  \"inline\",\n  \"table\",\n  \"list\",\n  \"heading\",\n  \"hr\",\n  \"softbreak\",\n  \"block\",\n];\n\nexport const getRules = (\n  options: Required<MarkdownItAttrsOptions>,\n): AttrRule[] => {\n  const enabledRules =\n    // disable\n    options.rule === false\n      ? []\n      : Array.isArray(options.rule)\n        ? // user specific rules\n          options.rule.filter((item) => AVAILABLE_RULES.includes(item))\n        : AVAILABLE_RULES;\n\n  const rules: AttrRule[] = [];\n\n  if (enabledRules.includes(\"fence\")) rules.push(getFenceRule(options));\n  if (enabledRules.includes(\"inline\")) rules.push(...getInlineRules(options));\n  if (enabledRules.includes(\"table\")) rules.push(...getTableRules(options));\n  if (enabledRules.includes(\"list\")) rules.push(...getListRules(options));\n  if (enabledRules.includes(\"softbreak\")) rules.push(getSoftBreakRule(options));\n  if (enabledRules.includes(\"hr\")) rules.push(getHrRule(options));\n  if (enabledRules.includes(\"block\")) rules.push(getBlockRule(options));\n  // heading rule is fully covered by block rules\n  else if (enabledRules.includes(\"heading\"))\n    rules.push(getHeadingRule(options));\n\n  return rules;\n};\n","/**\n * Forked and modified from https://github.com/arve0/markdown-it-attrs/\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleCore } from \"markdown-it/lib/parser_core.mjs\";\n\nimport { testRule } from \"./helper/index.js\";\nimport type { MarkdownItAttrsOptions } from \"./options.js\";\nimport type { DelimiterRange } from \"./rules/index.js\";\nimport { getRules } from \"./rules/index.js\";\n\nexport const attrs: PluginWithOptions<MarkdownItAttrsOptions> = (\n  md,\n  { left = \"{\", right = \"}\", allowed = [], rule = \"all\" } = {},\n) => {\n  const rules = getRules({\n    left,\n    right,\n    allowed,\n    rule,\n  });\n\n  const attrsRule: RuleCore = ({ tokens }) => {\n    for (let index = 0; index < tokens.length; index++)\n      for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n        const pattern = rules[ruleIndex];\n        // position of child with offset 0\n        let position: null | number = null;\n        let range: DelimiterRange | null = null;\n\n        const match = pattern.tests.every((test) => {\n          const result = testRule(tokens, index, test);\n\n          if (result.position !== null) ({ position } = result);\n          if (result.range) range = result.range;\n\n          return result.match;\n        });\n\n        if (match) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          pattern.transform(tokens, index, position!, range!);\n\n          if (\n            pattern.name === \"inline attributes\" ||\n            pattern.name === \"inline nesting self-close\"\n          )\n            // retry, may be several inline attributes\n            ruleIndex--;\n        }\n      }\n  };\n\n  md.core.ruler.before(\"linkify\", \"attrs\", attrsRule);\n};\n"],"names":["CLASS_MARKER","ID_MARKER","PAIR_SEPARATOR","KEY_SEPARATOR","QUOTE_MARKER","isAllowedKeyChar","charCode","getAttrs","str","range","allowed","key","value","parsingKey","valueInsideQuotes","attrs","index","attr","item","addAttrs","token","content","getDelimiterChecker","left","right","where","leftLength","rightLength","minContentLength","start","end","nextCharPos","firstCharCode","length","getMatchingOpeningToken","tokens","level","type","currentToken","getArrayItem","arr","testRule","rule","testResult","isShift","tokenIndex","childTests","children","match","childTest","result","position","childIndex","ruleDetail","isSpace","code","getBlockRule","options","attrStartIndex","hasTrailingSpace","closingTokenIndex","openingToken","getFenceRule","_","info","getHeadingRule","getInlineRules","childTokens","targetToken","attrsEndIndex","getListRules","listOpenIndex","getSoftBreakRule","getHrRule","pos","markerCode","count","inlineToken","hideTokenContent","childToken","handleRowspan","startIndex","endIndex","columnCount","colspan","rowspan","adjustedColumnCount","remainingRows","trOpenToken","handleTableRow","expectedColumnCount","cellCount","handleColspan","tbodyOpenIndex","cellIndices","startToken","colspanNum","cellOffset","realColspan","hiddenStartIndex","getTableRules","tableOpeningToken","cellOpenToken","thCloseToken","currentIndex","tHeadOpenToken","tbodyOpenToken","maxLevel","AVAILABLE_RULES","getRules","enabledRules","rules","md","attrsRule","ruleIndex","pattern","test"],"mappings":"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","x_google_ignoreList":[7]}