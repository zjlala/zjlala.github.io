{"version":3,"file":"browser.js","sources":["../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs","../src/plugin.ts"],"sourcesContent":["// Utilities\n//\n\nimport * as mdurl from 'mdurl'\nimport * as ucmicro from 'uc.micro'\nimport { decodeHTML } from 'entities'\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = decodeHTML(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return ucmicro.P.test(ch) || ucmicro.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl, ucmicro }\n\nexport {\n  lib,\n  assign,\n  isString,\n  has,\n  unescapeMd,\n  unescapeAll,\n  isValidEntityCode,\n  fromCodePoint,\n  escapeHtml,\n  arrayReplaceAt,\n  isSpace,\n  isWhiteSpace,\n  isMdAsciiPunct,\n  isPunctChar,\n  escapeRE,\n  normalizeReference\n}\n","/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Count preceding backslashes from a position\n */\nconst countPrecedingBackslashes = (\n  src: string,\n  pos: number,\n  minPos = 0,\n): number => {\n  let count = 0;\n  let checkPos = pos - 1;\n\n  while (checkPos >= minPos && src.charCodeAt(checkPos) === 92 /* \\ */) {\n    count++;\n    checkPos--;\n  }\n\n  return count;\n};\n\n/*\n * Test if potential opening or closing delimiter for dollar syntax\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDollarDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevCharCode = state.src.charCodeAt(pos - 1);\n  const nextCharCode = state.src.charCodeAt(pos + 1);\n\n  return {\n    canOpen: allowInlineWithSpace || !isSpace(nextCharCode),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isn't followed by a number\n     */\n    canClose:\n      !((nextCharCode >= 48 /* 0 */ && nextCharCode <= 57) /* 9 */) &&\n      (allowInlineWithSpace || !isSpace(prevCharCode)),\n  };\n};\n\n/*\n * Parse inline math with dollar signs: $...$\n */\nconst getDollarInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    if (state.src[state.pos] !== \"$\") return false;\n\n    let delimState = isValidDollarDelim(state, state.pos, allowInlineWithSpace);\n\n    if (!delimState.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    let match = start;\n    let pos: number;\n    const max = state.src.lastIndexOf(\"$\");\n\n    if (max === -1) return false;\n\n    while ((match = state.src.indexOf(\"$\", match)) <= max) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src.charCodeAt(pos) === 92 /* \\ */) pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    delimState = isValidDollarDelim(state, match, allowInlineWithSpace);\n\n    if (!delimState.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      const token = state.push(\"math_inline\", \"math\", 0);\n\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\n/*\n * Parse inline math with bracket syntax: \\(...\\)\n */\nconst getBracketInlineTex = (): RuleInline => (state, silent) => {\n  const start = state.pos;\n\n  // Check for opening \\(\n  if (\n    state.src.charCodeAt(start) !== 92 /* \\ */ ||\n    state.src.charCodeAt(start + 1) !== 40 /* ( */\n  )\n    return false;\n\n  // Look for closing \\)\n  let pos = start + 2;\n  let found = false;\n  const srcLength = state.src.length;\n\n  while (pos < srcLength - 1) {\n    if (\n      state.src.charCodeAt(pos) === 92 /* \\ */ &&\n      state.src.charCodeAt(pos + 1) === 41 /* ) */\n    ) {\n      // Check if the opening \\( was escaped\n      const openingBackslashes = countPrecedingBackslashes(state.src, start);\n\n      // If opening \\( is escaped (odd number of preceding backslashes), don't parse\n      if (openingBackslashes % 2 === 1) return false;\n\n      // Check if the closing \\) is escaped\n      const closingBackslashes = countPrecedingBackslashes(\n        state.src,\n        pos,\n        start + 2,\n      );\n\n      // If closing \\) is not escaped (even number of preceding backslashes), we found it\n      if (closingBackslashes % 2 === 0) {\n        found = true;\n        break;\n      }\n    }\n    pos++;\n  }\n\n  if (!found) return false;\n\n  if (!silent) {\n    const token = state.push(\"math_inline\", \"math\", 0);\n\n    token.markup = \"\\\\(\";\n    token.content = state.src.slice(start + 2, pos);\n  }\n\n  state.pos = pos + 2;\n\n  return true;\n};\n\n/*\n * Parse block math with dollar signs: $$...$$\n */\nconst dollarBlockTex: RuleBlock = (state, startLine, endLine, silent) => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  let end = state.eMarks[startLine];\n\n  if (start + 2 > end) return false;\n\n  if (\n    state.src.charCodeAt(start) !== 36 /* $ */ ||\n    state.src.charCodeAt(start + 1) !== 36 /* $ */\n  )\n    return false;\n\n  if (silent) return true;\n\n  let contentEnd = state.skipSpacesBack(end, start);\n  let pos = start + 2;\n  let firstLine: string;\n  let found = false;\n\n  if (\n    contentEnd - pos >= 2 &&\n    state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n    state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n  ) {\n    // Single line expression\n    firstLine = state.src.slice(pos, contentEnd - 2);\n    found = true;\n  } else {\n    firstLine = state.src.slice(pos, end);\n  }\n\n  let current = startLine;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= endLine) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    end = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    contentEnd = state.skipSpacesBack(end, pos);\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n      state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n    ) {\n      lastLine = state.src.slice(pos, contentEnd - 2);\n      found = true;\n    }\n  }\n\n  state.line = found ? current + 1 : current;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [startLine, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\n/*\n * Parse block math with bracket syntax: \\[...\\]\n */\nconst getBracketBlockTex =\n  (): RuleBlock => (state, startLine, endLine, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    let end = state.eMarks[startLine];\n\n    if (start + 2 > end) return false;\n\n    if (\n      state.src.charCodeAt(start) !== 92 /* \\ */ ||\n      state.src.charCodeAt(start + 1) !== 91 /* [ */\n    )\n      return false;\n\n    if (silent) return true;\n\n    let contentEnd = state.skipSpacesBack(end, start);\n    let pos = start + 2;\n    let firstLine: string;\n    let found = false;\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n      state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n    ) {\n      // Single line expression\n      firstLine = state.src.slice(pos, contentEnd - 2);\n      found = true;\n    } else {\n      firstLine = state.src.slice(pos, end);\n    }\n\n    let current = startLine;\n    let lastLine = \"\";\n\n    while (!found) {\n      current++;\n      if (current >= endLine) break;\n\n      pos = state.bMarks[current] + state.tShift[current];\n      end = state.eMarks[current];\n\n      // non-empty line with negative indent should stop the list:\n      if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n      // found end marker\n      contentEnd = state.skipSpacesBack(end, pos);\n\n      if (\n        contentEnd - pos >= 2 &&\n        state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n        state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n      ) {\n        lastLine = state.src.slice(pos, contentEnd - 2).trimEnd();\n        found = true;\n      }\n    }\n\n    if (!found) return false;\n\n    state.line = current + 1;\n\n    const token = state.push(\"math_block\", \"math\", 0);\n\n    token.block = true;\n    token.content =\n      (firstLine ? `${firstLine}\\n` : \"\") +\n      state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n      (lastLine ? `${lastLine}\\n` : \"\");\n    token.map = [startLine, state.line];\n    token.markup = \"\\\\[\";\n\n    return true;\n  };\n\nconst ruleOptions = {\n  alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    delimiters = \"dollars\",\n    render,\n  } = options;\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fence!(...args);\n    };\n  }\n\n  // Register inline and block rules based on delimiters option\n  if (delimiters === \"dollars\" || delimiters === \"all\") {\n    md.inline.ruler.after(\n      \"escape\",\n      \"math_inline_dollar\",\n      getDollarInlineTex(allowInlineWithSpace),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_dollar\",\n      dollarBlockTex,\n      ruleOptions,\n    );\n  }\n\n  if (delimiters === \"brackets\" || delimiters === \"all\") {\n    md.inline.ruler.before(\n      \"escape\",\n      \"math_inline_bracket\",\n      getBracketInlineTex(),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_bracket\",\n      getBracketBlockTex(),\n      ruleOptions,\n    );\n  }\n\n  md.renderer.rules.math_inline = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules.math_block = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["isSpace","code","countPrecedingBackslashes","src","pos","minPos","count","checkPos","isValidDollarDelim","state","allowInlineWithSpace","prevCharCode","nextCharCode","getDollarInlineTex","silent","delimState","start","match","max","token","getBracketInlineTex","found","srcLength","dollarBlockTex","startLine","endLine","end","contentEnd","firstLine","current","lastLine","getBracketBlockTex","ruleOptions","tex","md","options","mathFence","delimiters","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"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","x_google_ignoreList":[0]}