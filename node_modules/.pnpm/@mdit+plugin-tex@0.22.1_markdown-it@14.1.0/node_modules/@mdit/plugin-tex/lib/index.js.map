{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked from https://github.com/waylonflinn/markdown-it-katex/blob/master/index.js\n */\n\nimport type { PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nimport type { MarkdownItTexOptions } from \"./options.js\";\n\n/*\n * Count preceding backslashes from a position\n */\nconst countPrecedingBackslashes = (\n  src: string,\n  pos: number,\n  minPos = 0,\n): number => {\n  let count = 0;\n  let checkPos = pos - 1;\n\n  while (checkPos >= minPos && src.charCodeAt(checkPos) === 92 /* \\ */) {\n    count++;\n    checkPos--;\n  }\n\n  return count;\n};\n\n/*\n * Test if potential opening or closing delimiter for dollar syntax\n * Assumes that there is a \"$\" at state.src[pos]\n */\nconst isValidDollarDelim = (\n  state: StateInline,\n  pos: number,\n  allowInlineWithSpace: boolean,\n): { canOpen: boolean; canClose: boolean } => {\n  const prevCharCode = state.src.charCodeAt(pos - 1);\n  const nextCharCode = state.src.charCodeAt(pos + 1);\n\n  return {\n    canOpen: allowInlineWithSpace || !isSpace(nextCharCode),\n\n    /*\n     * Check non-whitespace conditions for opening and closing, and\n     * check that closing delimiter isn't followed by a number\n     */\n    canClose:\n      !((nextCharCode >= 48 /* 0 */ && nextCharCode <= 57) /* 9 */) &&\n      (allowInlineWithSpace || !isSpace(prevCharCode)),\n  };\n};\n\n/*\n * Parse inline math with dollar signs: $...$\n */\nconst getDollarInlineTex =\n  (allowInlineWithSpace: boolean): RuleInline =>\n  (state, silent) => {\n    if (state.src[state.pos] !== \"$\") return false;\n\n    let delimState = isValidDollarDelim(state, state.pos, allowInlineWithSpace);\n\n    if (!delimState.canOpen) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos++;\n\n      return true;\n    }\n\n    /*\n     * First check for and bypass all properly escaped delimiters\n     * This loop will assume that the first leading backtick can not\n     * be the first character in state.src, which is known since\n     * we have found an opening delimiter already.\n     */\n    const start = state.pos + 1;\n\n    let match = start;\n    let pos: number;\n    const max = state.src.lastIndexOf(\"$\");\n\n    if (max === -1) return false;\n\n    while ((match = state.src.indexOf(\"$\", match)) <= max) {\n      /*\n       * Found potential $, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      pos = match - 1;\n      while (state.src.charCodeAt(pos) === 92 /* \\ */) pos--;\n\n      // Even number of escapes, potential closing delimiter found\n      if ((match - pos) % 2 === 1) break;\n\n      match++;\n    }\n\n    // No closing delimiter found.  Consume $ and continue.\n    if (match === -1) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n      if (!silent) state.pending += \"$$\";\n\n      state.pos = start + 1;\n\n      return true;\n    }\n\n    // Check for valid closing delimiter\n    delimState = isValidDollarDelim(state, match, allowInlineWithSpace);\n\n    if (!delimState.canClose) {\n      if (!silent) state.pending += \"$\";\n\n      state.pos = start;\n\n      return true;\n    }\n\n    if (!silent) {\n      const token = state.push(\"math_inline\", \"math\", 0);\n\n      token.markup = \"$\";\n      token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n\n    return true;\n  };\n\n/*\n * Parse inline math with bracket syntax: \\(...\\)\n */\nconst getBracketInlineTex = (): RuleInline => (state, silent) => {\n  const start = state.pos;\n\n  // Check for opening \\(\n  if (\n    state.src.charCodeAt(start) !== 92 /* \\ */ ||\n    state.src.charCodeAt(start + 1) !== 40 /* ( */\n  )\n    return false;\n\n  // Look for closing \\)\n  let pos = start + 2;\n  let found = false;\n  const srcLength = state.src.length;\n\n  while (pos < srcLength - 1) {\n    if (\n      state.src.charCodeAt(pos) === 92 /* \\ */ &&\n      state.src.charCodeAt(pos + 1) === 41 /* ) */\n    ) {\n      // Check if the opening \\( was escaped\n      const openingBackslashes = countPrecedingBackslashes(state.src, start);\n\n      // If opening \\( is escaped (odd number of preceding backslashes), don't parse\n      if (openingBackslashes % 2 === 1) return false;\n\n      // Check if the closing \\) is escaped\n      const closingBackslashes = countPrecedingBackslashes(\n        state.src,\n        pos,\n        start + 2,\n      );\n\n      // If closing \\) is not escaped (even number of preceding backslashes), we found it\n      if (closingBackslashes % 2 === 0) {\n        found = true;\n        break;\n      }\n    }\n    pos++;\n  }\n\n  if (!found) return false;\n\n  if (!silent) {\n    const token = state.push(\"math_inline\", \"math\", 0);\n\n    token.markup = \"\\\\(\";\n    token.content = state.src.slice(start + 2, pos);\n  }\n\n  state.pos = pos + 2;\n\n  return true;\n};\n\n/*\n * Parse block math with dollar signs: $$...$$\n */\nconst dollarBlockTex: RuleBlock = (state, startLine, endLine, silent) => {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  let end = state.eMarks[startLine];\n\n  if (start + 2 > end) return false;\n\n  if (\n    state.src.charCodeAt(start) !== 36 /* $ */ ||\n    state.src.charCodeAt(start + 1) !== 36 /* $ */\n  )\n    return false;\n\n  if (silent) return true;\n\n  let contentEnd = state.skipSpacesBack(end, start);\n  let pos = start + 2;\n  let firstLine: string;\n  let found = false;\n\n  if (\n    contentEnd - pos >= 2 &&\n    state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n    state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n  ) {\n    // Single line expression\n    firstLine = state.src.slice(pos, contentEnd - 2);\n    found = true;\n  } else {\n    firstLine = state.src.slice(pos, end);\n  }\n\n  let current = startLine;\n  let lastLine = \"\";\n\n  while (!found) {\n    current++;\n    if (current >= endLine) break;\n\n    pos = state.bMarks[current] + state.tShift[current];\n    end = state.eMarks[current];\n\n    // non-empty line with negative indent should stop the list:\n    if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n    // found end marker\n    contentEnd = state.skipSpacesBack(end, pos);\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 36 /* $ */ &&\n      state.src.charCodeAt(contentEnd - 2) === 36 /* $ */\n    ) {\n      lastLine = state.src.slice(pos, contentEnd - 2);\n      found = true;\n    }\n  }\n\n  state.line = found ? current + 1 : current;\n\n  const token = state.push(\"math_block\", \"math\", 0);\n\n  token.block = true;\n  token.content =\n    (firstLine ? `${firstLine}\\n` : \"\") +\n    state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n    (lastLine ? `${lastLine}\\n` : \"\");\n  token.map = [startLine, state.line];\n  token.markup = \"$$\";\n\n  return true;\n};\n\n/*\n * Parse block math with bracket syntax: \\[...\\]\n */\nconst getBracketBlockTex =\n  (): RuleBlock => (state, startLine, endLine, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    let end = state.eMarks[startLine];\n\n    if (start + 2 > end) return false;\n\n    if (\n      state.src.charCodeAt(start) !== 92 /* \\ */ ||\n      state.src.charCodeAt(start + 1) !== 91 /* [ */\n    )\n      return false;\n\n    if (silent) return true;\n\n    let contentEnd = state.skipSpacesBack(end, start);\n    let pos = start + 2;\n    let firstLine: string;\n    let found = false;\n\n    if (\n      contentEnd - pos >= 2 &&\n      state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n      state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n    ) {\n      // Single line expression\n      firstLine = state.src.slice(pos, contentEnd - 2);\n      found = true;\n    } else {\n      firstLine = state.src.slice(pos, end);\n    }\n\n    let current = startLine;\n    let lastLine = \"\";\n\n    while (!found) {\n      current++;\n      if (current >= endLine) break;\n\n      pos = state.bMarks[current] + state.tShift[current];\n      end = state.eMarks[current];\n\n      // non-empty line with negative indent should stop the list:\n      if (pos < end && state.tShift[current] < state.blkIndent) break;\n\n      // found end marker\n      contentEnd = state.skipSpacesBack(end, pos);\n\n      if (\n        contentEnd - pos >= 2 &&\n        state.src.charCodeAt(contentEnd - 1) === 93 /* ] */ &&\n        state.src.charCodeAt(contentEnd - 2) === 92 /* \\ */\n      ) {\n        lastLine = state.src.slice(pos, contentEnd - 2).trimEnd();\n        found = true;\n      }\n    }\n\n    if (!found) return false;\n\n    state.line = current + 1;\n\n    const token = state.push(\"math_block\", \"math\", 0);\n\n    token.block = true;\n    token.content =\n      (firstLine ? `${firstLine}\\n` : \"\") +\n      state.getLines(startLine + 1, current, state.tShift[startLine], true) +\n      (lastLine ? `${lastLine}\\n` : \"\");\n    token.map = [startLine, state.line];\n    token.markup = \"\\\\[\";\n\n    return true;\n  };\n\nconst ruleOptions = {\n  alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n};\n\nexport const tex: PluginWithOptions<MarkdownItTexOptions> = (md, options) => {\n  if (typeof options?.render !== \"function\")\n    throw new Error('[@mdit/plugin-tex]: \"render\" option should be a function');\n\n  const {\n    allowInlineWithSpace = false,\n    mathFence = false,\n    delimiters = \"dollars\",\n    render,\n  } = options;\n\n  // Handle ```math blocks\n  if (mathFence) {\n    const fence = md.renderer.rules.fence;\n\n    md.renderer.rules.fence = (...args): string => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const [tokens, index, , env] = args;\n      const { content, info } = tokens[index];\n\n      if (info.trim() === \"math\") return render(content, true, env);\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fence!(...args);\n    };\n  }\n\n  // Register inline and block rules based on delimiters option\n  if (delimiters === \"dollars\" || delimiters === \"all\") {\n    md.inline.ruler.after(\n      \"escape\",\n      \"math_inline_dollar\",\n      getDollarInlineTex(allowInlineWithSpace),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_dollar\",\n      dollarBlockTex,\n      ruleOptions,\n    );\n  }\n\n  if (delimiters === \"brackets\" || delimiters === \"all\") {\n    md.inline.ruler.before(\n      \"escape\",\n      \"math_inline_bracket\",\n      getBracketInlineTex(),\n    );\n    md.block.ruler.after(\n      \"blockquote\",\n      \"math_block_bracket\",\n      getBracketBlockTex(),\n      ruleOptions,\n    );\n  }\n\n  md.renderer.rules.math_inline = (tokens, index, _options, env): string =>\n    render(tokens[index].content, false, env);\n  md.renderer.rules.math_block = (tokens, index, _options, env): string =>\n    render(tokens[index].content, true, env);\n};\n"],"names":["countPrecedingBackslashes","src","pos","minPos","count","checkPos","isValidDollarDelim","state","allowInlineWithSpace","prevCharCode","nextCharCode","isSpace","getDollarInlineTex","silent","delimState","start","match","max","token","getBracketInlineTex","found","srcLength","dollarBlockTex","startLine","endLine","end","contentEnd","firstLine","current","lastLine","getBracketBlockTex","ruleOptions","tex","md","options","mathFence","delimiters","render","fence","args","tokens","index","env","content","info","_options"],"mappings":"2DAeA,MAAMA,EAA4B,CAChCC,EACAC,EACAC,EAAS,IACE,CACX,IAAIC,EAAQ,EACRC,EAAWH,EAAM,EAErB,KAAOG,GAAYF,GAAUF,EAAI,WAAWI,CAAQ,IAAM,IACxDD,IACAC,IAGF,OAAOD,CACT,EAMME,EAAqB,CACzBC,EACAL,EACAM,IAC4C,CAC5C,MAAMC,EAAeF,EAAM,IAAI,WAAWL,EAAM,CAAC,EAC3CQ,EAAeH,EAAM,IAAI,WAAWL,EAAM,CAAC,EAEjD,MAAO,CACL,QAASM,GAAwB,CAACG,EAAQD,CAAY,EAMtD,SACE,EAAGA,GAAgB,IAAcA,GAAgB,MAChDF,GAAwB,CAACG,EAAQF,CAAY,EAClD,CACF,EAKMG,EACHJ,GACD,CAACD,EAAOM,IAAW,CACjB,GAAIN,EAAM,IAAIA,EAAM,GAAG,IAAM,IAAK,MAElC,GAAA,IAAIO,EAAaR,EAAmBC,EAAOA,EAAM,IAAKC,CAAoB,EAE1E,GAAI,CAACM,EAAW,QACd,OAAKD,IAAQN,EAAM,SAAW,KAE9BA,EAAM,MAEC,GAST,MAAMQ,EAAQR,EAAM,IAAM,EAE1B,IAAIS,EAAQD,EACRb,EACJ,MAAMe,EAAMV,EAAM,IAAI,YAAY,GAAG,EAErC,GAAIU,IAAQ,GAAI,MAAO,GAEvB,MAAQD,EAAQT,EAAM,IAAI,QAAQ,IAAKS,CAAK,IAAMC,GAAK,CAMrD,IADAf,EAAMc,EAAQ,EACPT,EAAM,IAAI,WAAWL,CAAG,IAAM,IAAYA,IAGjD,IAAKc,EAAQd,GAAO,IAAM,EAAG,MAE7Bc,GACF,CAGA,GAAIA,IAAU,GACZ,OAAKH,IAAQN,EAAM,SAAW,KAE9BA,EAAM,IAAMQ,EAEL,GAIT,GAAIC,EAAQD,IAAU,EACpB,OAAKF,IAAQN,EAAM,SAAW,MAE9BA,EAAM,IAAMQ,EAAQ,EAEb,GAMT,GAFAD,EAAaR,EAAmBC,EAAOS,EAAOR,CAAoB,EAE9D,CAACM,EAAW,SACd,OAAKD,IAAQN,EAAM,SAAW,KAE9BA,EAAM,IAAMQ,EAEL,GAGT,GAAI,CAACF,EAAQ,CACX,MAAMK,EAAQX,EAAM,KAAK,cAAe,OAAQ,CAAC,EAEjDW,EAAM,OAAS,IACfA,EAAM,QAAUX,EAAM,IAAI,MAAMQ,EAAOC,CAAK,CAC9C,CAEA,OAAAT,EAAM,IAAMS,EAAQ,EAEb,EACT,EAKIG,EAAsB,IAAkB,CAACZ,EAAOM,IAAW,CAC/D,MAAME,EAAQR,EAAM,IAGpB,GACEA,EAAM,IAAI,WAAWQ,CAAK,IAAM,IAChCR,EAAM,IAAI,WAAWQ,EAAQ,CAAC,IAAM,GAEpC,MAAO,GAGT,IAAIb,EAAMa,EAAQ,EACdK,EAAQ,GACZ,MAAMC,EAAYd,EAAM,IAAI,OAE5B,KAAOL,EAAMmB,EAAY,GAAG,CAC1B,GACEd,EAAM,IAAI,WAAWL,CAAG,IAAM,IAC9BK,EAAM,IAAI,WAAWL,EAAM,CAAC,IAAM,GAClC,CAKA,GAH2BF,EAA0BO,EAAM,IAAKQ,CAAK,EAG5C,IAAM,EAAG,MAAO,GAUzC,GAP2Bf,EACzBO,EAAM,IACNL,EACAa,EAAQ,CACV,EAGyB,IAAM,EAAG,CAChCK,EAAQ,GACR,KACF,CACF,CACAlB,GACF,CAEA,GAAI,CAACkB,EAAO,MAAO,GAEnB,GAAI,CAACP,EAAQ,CACX,MAAMK,EAAQX,EAAM,KAAK,cAAe,OAAQ,CAAC,EAEjDW,EAAM,OAAS,MACfA,EAAM,QAAUX,EAAM,IAAI,MAAMQ,EAAQ,EAAGb,CAAG,CAChD,CAEA,OAAAK,EAAM,IAAML,EAAM,EAEX,EACT,EAKMoB,EAA4B,CAACf,EAAOgB,EAAWC,EAASX,IAAW,CACvE,MAAME,EAAQR,EAAM,OAAOgB,CAAS,EAAIhB,EAAM,OAAOgB,CAAS,EAC9D,IAAIE,EAAMlB,EAAM,OAAOgB,CAAS,EAIhC,GAFIR,EAAQ,EAAIU,GAGdlB,EAAM,IAAI,WAAWQ,CAAK,IAAM,IAChCR,EAAM,IAAI,WAAWQ,EAAQ,CAAC,IAAM,GAEpC,MAEF,GAAA,GAAIF,EAAQ,SAEZ,IAAIa,EAAanB,EAAM,eAAekB,EAAKV,CAAK,EAC5Cb,EAAMa,EAAQ,EACdY,EACAP,EAAQ,GAGVM,EAAaxB,GAAO,GACpBK,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IACzCnB,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IAGzCC,EAAYpB,EAAM,IAAI,MAAML,EAAKwB,EAAa,CAAC,EAC/CN,EAAQ,IAERO,EAAYpB,EAAM,IAAI,MAAML,EAAKuB,CAAG,EAGtC,IAAIG,EAAUL,EACVM,EAAW,GAEf,KAAO,CAACT,IACNQ,IACI,EAAAA,GAAWJ,IAEftB,EAAMK,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,OAAOqB,CAAO,EAClDH,EAAMlB,EAAM,OAAOqB,CAAO,EAGtB1B,EAAMuB,GAAOlB,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,cAG/CmB,EAAanB,EAAM,eAAekB,EAAKvB,CAAG,EAGxCwB,EAAaxB,GAAO,GACpBK,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IACzCnB,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,KAEzCG,EAAWtB,EAAM,IAAI,MAAML,EAAKwB,EAAa,CAAC,EAC9CN,EAAQ,IAIZb,EAAM,KAAOa,EAAQQ,EAAU,EAAIA,EAEnC,MAAMV,EAAQX,EAAM,KAAK,aAAc,OAAQ,CAAC,EAEhD,OAAAW,EAAM,MAAQ,GACdA,EAAM,SACHS,EAAY,GAAGA,CAAS;AAAA,EAAO,IAChCpB,EAAM,SAASgB,EAAY,EAAGK,EAASrB,EAAM,OAAOgB,CAAS,EAAG,EAAI,GACnEM,EAAW,GAAGA,CAAQ;AAAA,EAAO,IAChCX,EAAM,IAAM,CAACK,EAAWhB,EAAM,IAAI,EAClCW,EAAM,OAAS,KAER,EACT,EAKMY,EACJ,IAAiB,CAACvB,EAAOgB,EAAWC,EAASX,IAAW,CACtD,MAAME,EAAQR,EAAM,OAAOgB,CAAS,EAAIhB,EAAM,OAAOgB,CAAS,EAC9D,IAAIE,EAAMlB,EAAM,OAAOgB,CAAS,EAIhC,GAFIR,EAAQ,EAAIU,GAGdlB,EAAM,IAAI,WAAWQ,CAAK,IAAM,IAChCR,EAAM,IAAI,WAAWQ,EAAQ,CAAC,IAAM,GAEpC,SAEF,GAAIF,EAAQ,MAEZ,GAAA,IAAIa,EAAanB,EAAM,eAAekB,EAAKV,CAAK,EAC5Cb,EAAMa,EAAQ,EACdY,EACAP,EAAQ,GAGVM,EAAaxB,GAAO,GACpBK,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IACzCnB,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IAGzCC,EAAYpB,EAAM,IAAI,MAAML,EAAKwB,EAAa,CAAC,EAC/CN,EAAQ,IAERO,EAAYpB,EAAM,IAAI,MAAML,EAAKuB,CAAG,EAGtC,IAAIG,EAAUL,EACVM,EAAW,GAEf,KAAO,CAACT,IACNQ,IACI,EAAAA,GAAWJ,IAEftB,EAAMK,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,OAAOqB,CAAO,EAClDH,EAAMlB,EAAM,OAAOqB,CAAO,EAGtB1B,EAAMuB,GAAOlB,EAAM,OAAOqB,CAAO,EAAIrB,EAAM,cAG/CmB,EAAanB,EAAM,eAAekB,EAAKvB,CAAG,EAGxCwB,EAAaxB,GAAO,GACpBK,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,IACzCnB,EAAM,IAAI,WAAWmB,EAAa,CAAC,IAAM,KAEzCG,EAAWtB,EAAM,IAAI,MAAML,EAAKwB,EAAa,CAAC,EAAE,QAAA,EAChDN,EAAQ,IAIZ,GAAI,CAACA,EAAO,SAEZb,EAAM,KAAOqB,EAAU,EAEvB,MAAMV,EAAQX,EAAM,KAAK,aAAc,OAAQ,CAAC,EAEhD,OAAAW,EAAM,MAAQ,GACdA,EAAM,SACHS,EAAY,GAAGA,CAAS;AAAA,EAAO,IAChCpB,EAAM,SAASgB,EAAY,EAAGK,EAASrB,EAAM,OAAOgB,CAAS,EAAG,EAAI,GACnEM,EAAW,GAAGA,CAAQ;AAAA,EAAO,IAChCX,EAAM,IAAM,CAACK,EAAWhB,EAAM,IAAI,EAClCW,EAAM,OAAS,MAER,EACT,EAEIa,EAAc,CAClB,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,EAEaC,EAA+C,CAACC,EAAIC,IAAY,CAC3E,GAAI,OAAOA,GAAS,QAAW,WAC7B,MAAM,IAAI,MAAM,0DAA0D,EAE5E,KAAM,CACJ,qBAAA1B,EAAuB,GACvB,UAAA2B,EAAY,GACZ,WAAAC,EAAa,UACb,OAAAC,CACF,EAAIH,EAGJ,GAAIC,EAAW,CACb,MAAMG,EAAQL,EAAG,SAAS,MAAM,MAEhCA,EAAG,SAAS,MAAM,MAAQ,IAAIM,IAAiB,CAE7C,KAAM,CAACC,EAAQC,GAASC,CAAG,EAAIH,EACzB,CAAE,QAAAI,EAAS,KAAAC,CAAK,EAAIJ,EAAOC,CAAK,EAEtC,OAAIG,EAAK,SAAW,OAAeP,EAAOM,EAAS,GAAMD,CAAG,EAGrDJ,EAAO,GAAGC,CAAI,CACvB,CACF,EAGIH,IAAe,WAAaA,IAAe,SAC7CH,EAAG,OAAO,MAAM,MACd,SACA,qBACArB,EAAmBJ,CAAoB,CACzC,EACAyB,EAAG,MAAM,MAAM,MACb,aACA,oBACAX,EACAS,CACF,IAGEK,IAAe,YAAcA,IAAe,SAC9CH,EAAG,OAAO,MAAM,OACd,SACA,sBACAd,GACF,EACAc,EAAG,MAAM,MAAM,MACb,aACA,qBACAH,EACAC,EAAAA,CACF,GAGFE,EAAG,SAAS,MAAM,YAAc,CAACO,EAAQC,EAAOI,EAAUH,IACxDL,EAAOG,EAAOC,CAAK,EAAE,QAAS,GAAOC,CAAG,EAC1CT,EAAG,SAAS,MAAM,WAAa,CAACO,EAAQC,EAAOI,EAAUH,IACvDL,EAAOG,EAAOC,CAAK,EAAE,QAAS,GAAMC,CAAG,CAC3C"}