const d=(t,e,c)=>{const s=t.attrIndex(e),r=[e,c];s<0?t.attrPush(r):t.attrs[s]=r},f=(t,e)=>{const c=t[e].level-1;for(let s=e-1;s>=0;s--)if(t[s].level===c)return s;/* istanbul ignore next -- @preserve */return-1},x=t=>t?.type==="inline",T=t=>t?.type==="paragraph_open",m=t=>t?.type==="list_item_open",_=t=>/^\[[xX \u00A0]\][ \u00A0]/.test(t.content),I=(t,e)=>x(t[e])&&T(t[e-1])&&m(t[e-2])&&_(t[e]),y=(t,{disabled:e=!0,label:c=!0,containerClass:s="task-list-container",itemClass:r="task-list-item",checkboxClass:u="task-list-item-checkbox",labelClass:p="task-list-item-label"}={})=>{const b=l=>{const a=l.tokens;l.env.tasklistId||=0;for(let i=2;i<a.length;i++)if(I(a,i)){const n=a[i];n.children??=[],n.children[0].content=n.children[0].content.slice(3);const k=`task-item-${l.env.tasklistId++}`;if(c){const h=new l.Token("label_open","label",1);h.attrs=[["class",p],["for",k]],n.children.unshift(h),n.children.push(new l.Token("label_close","label",-1))}const o=new l.Token("checkbox_input","input",0);o.attrs=[["type","checkbox"],["class",u],["id",k]],/^\[[xX]\][ \u00A0]/.test(n.content)&&o.attrs.push(["checked","checked"]),e&&o.attrs.push(["disabled","disabled"]),n.children.unshift(o),d(a[i-2],"class",r),d(a[f(a,i-2)],"class",s)}return!0};t.core.ruler.after("inline","task_list",b)};export{y as tasklist};
//# sourceMappingURL=index.js.map
