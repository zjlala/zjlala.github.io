{"version":3,"file":"index.js","sources":["../src/legacy.ts","../src/obsidian.ts","../src/plugin.ts"],"sourcesContent":["/**\n * Fork and edited from https://github.com/tatsy/markdown-it-imsize/blob/master/lib/index.js\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\n// Parse image size\n//\nconst parseNumber = (\n  str: string,\n  pos: number,\n  max: number,\n): { ok: boolean; pos: number; value: string } => {\n  let char: number;\n  const start = pos;\n  const result = {\n    ok: false,\n    pos: pos,\n    value: \"\",\n  };\n\n  char = str.charCodeAt(pos);\n\n  while (\n    (pos < max && char >= 48 /* 0 */ && char <= 57) /* 9 */ ||\n    char === 37 /* % */\n  )\n    char = str.charCodeAt(++pos);\n\n  result.ok = true;\n  result.pos = pos;\n  result.value = str.slice(start, pos);\n\n  return result;\n};\n\nconst parseImageSize = (\n  str: string,\n  pos: number,\n  max: number,\n): { pos: number; width: string; height: string } | null => {\n  if (str.charCodeAt(pos) !== 61 /* = */) return null;\n\n  pos++;\n\n  // size must follow = without any white spaces as follows\n  // (1) =300x200\n  // (2) =300x\n  // (3) =x200\n  const char = str.charCodeAt(pos);\n\n  if (char !== 120 /* x */ && (char < 48 /* 0 */ || char > 57) /* 9 */)\n    return null;\n\n  // parse width\n  const width = parseNumber(str, pos, max);\n\n  pos = width.pos;\n\n  // next character must be 'x'\n  if (str.charCodeAt(pos++) !== 120 /* x */) return null;\n\n  // parse height\n  const height = parseNumber(str, pos, max);\n\n  pos = height.pos;\n\n  return {\n    pos,\n    width: width.value,\n    height: height.value,\n  };\n};\n\nconst legacyImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  let pos = labelEnd + 1;\n  let char: number;\n\n  let href = \"\";\n  let title = \"\";\n  let width = \"\";\n  let height = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n      pos++;\n    }\n\n    // minimal 5 => [link]( a =1x)\n    if (pos + 5 > max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    let skipSpaces = false;\n\n    if (start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        if (!isSpace(state.src.charCodeAt(pos))) {\n          skipSpaces = true;\n          break;\n        }\n      }\n\n      if (!skipSpaces || pos + 3 > max) return false;\n    } else {\n      title = \"\";\n    }\n\n    const sizeInfo = parseImageSize(state.src, pos, state.posMax);\n\n    if (sizeInfo) {\n      ({ width, height, pos } = sizeInfo);\n\n      // [link](  <href>  \"title\" =WxH  )\n      //                              ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        if (!isSpace(state.src.charCodeAt(pos))) break;\n      }\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let label = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      char = state.src.charCodeAt(pos);\n      if (char !== 32 /* space */ && char !== 9 /* \\t */) break;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) label = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) label = state.src.slice(labelStart, labelEnd);\n\n    const ref = env.references[state.md.utils.normalizeReference(label)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const content = state.src.slice(labelStart, labelEnd);\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(content, state.md, state.env, tokens);\n\n    const token = state.push(\"image\", \"img\", 0);\n\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n    if (width) attrs.push([\"width\", width]);\n    if (height) attrs.push([\"height\", height]);\n    token.attrs = attrs;\n\n    token.children = tokens;\n    token.content = content;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\n/**\n * @deprecated Recommended to use `imgSize` instead.\n */\nexport const legacyImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"image\", legacyImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst isNumber = (charCode: number): boolean =>\n  charCode >= 48 /* 0 */ && charCode <= 57; /* 9 */\n\n/**\n * Parse image size information from label text in Obsidian format\n * Format: `alt | width x height`\n */\nconst parseObsidianImageSize = (\n  label: string,\n): {\n  label: string;\n  width: string | null;\n  height: string | null;\n} | null => {\n  const max = label.length;\n  let pos = label.lastIndexOf(\"|\");\n\n  if (pos === -1) return null;\n\n  // Get original label part before the pipe\n  const origLabel = label.substring(0, pos++).trimEnd();\n\n  // Skip spaces after pipe\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n    pos++;\n  }\n\n  if (pos === max) return null;\n\n  const widthStart = pos;\n\n  while (pos < max && isNumber(label.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === widthStart || pos === max) return null;\n\n  const width = label.substring(widthStart, pos);\n\n  // Skip spaces after width\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n    pos++;\n  }\n\n  // Check for 'x' character - 只接受小写 x\n  if (pos === max || label.charCodeAt(pos++) !== 120 /* x */) return null;\n\n  // Skip spaces after 'x'\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) break;\n    pos++;\n  }\n\n  const heightStart = pos;\n\n  while (pos < max && isNumber(label.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === heightStart) return null;\n\n  // 验证宽度是有效的数字序列\n  const height = label.substring(heightStart, pos);\n  const widthNum = Number(width);\n  const heightNum = Number(height);\n\n  if (!widthNum && !heightNum) return null;\n\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos++))) return null;\n  }\n\n  return {\n    label: origLabel,\n    width: widthNum ? width : null,\n    height: heightNum ? height : null,\n  };\n};\n\nexport const obsidianImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const sizeInfo = parseObsidianImageSize(rawLabel);\n\n  if (!sizeInfo) return false;\n\n  const { label, width, height } = sizeInfo;\n\n  let pos = labelEnd + 1;\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n      pos++;\n    }\n\n    if (pos === max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        if (!isSpace(state.src.charCodeAt(pos))) break;\n      }\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref =\n      env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n\n    if (width) attrs.push([\"width\", width]);\n    if (height) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const obsidianImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"obsidian-img-size\", obsidianImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst isNumber = (charCode: number): boolean =>\n  charCode >= 48 /* 0 */ && charCode <= 57; /* 9 */\n\n/**\n * Parse image size information from label text\n * Format: `alt =width x height`\n */\nconst parseImageSize = (\n  label: string,\n): { label: string; width: string | null; height: string | null } | null => {\n  const max = label.length;\n  let pos = label.lastIndexOf(\"=\");\n\n  if (pos === -1 || pos + 3 > max) return null;\n  if (pos !== 0 && !isSpace(label.charCodeAt(pos - 1))) return null;\n\n  const origLabel = label.substring(0, pos++).trimEnd();\n\n  let width: string | null = null;\n  let height: string | null = null;\n\n  if (isNumber(label.charCodeAt(pos))) {\n    const startPos = pos;\n\n    while (pos < max && isNumber(label.charCodeAt(pos))) {\n      pos++;\n    }\n\n    width = label.substring(startPos, pos);\n\n    if (label.charCodeAt(pos++) !== 120 /* x */) return null;\n  } else if (label.charCodeAt(pos++) === 120 /* x */) {\n    // no width info\n  } else {\n    return null;\n  }\n\n  if (pos < max) {\n    const startPos = pos;\n\n    while (pos < max && isNumber(label.charCodeAt(pos))) {\n      pos++;\n    }\n\n    if (pos > startPos) height = label.substring(startPos, pos);\n  }\n\n  while (pos < max) {\n    if (!isSpace(label.charCodeAt(pos))) return null;\n    pos++;\n  }\n\n  return {\n    label: origLabel,\n    width,\n    height,\n  };\n};\n\nexport const imgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charCodeAt(state.pos) !== 33 /* ! */ ||\n    state.src.charCodeAt(state.pos + 1) !== 91 /* [ */\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const sizeInfo = parseImageSize(rawLabel);\n\n  if (!sizeInfo) return false;\n\n  const { label, width, height } = sizeInfo;\n\n  let pos = labelEnd + 1;\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n      pos++;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        if (!isSpace(state.src.charCodeAt(pos))) break;\n      }\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      if (!isSpace(state.src.charCodeAt(pos))) break;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref =\n      env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n    if (width) attrs.push([\"width\", width]);\n    if (height) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const imgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"img-size\", imgSizeRule);\n};\n"],"names":["parseNumber","str","pos","max","char","start","result","parseImageSize","width","height","legacyImgSizeRule","state","silent","env","oldPos","labelStart","labelEnd","href","title","isSpace","res","skipSpaces","sizeInfo","label","ref","content","tokens","token","attrs","legacyImgSize","md","isNumber","charCode","parseObsidianImageSize","origLabel","widthStart","heightStart","widthNum","heightNum","obsidianImgSizeRule","rawLabel","referenceLabel","obsidianImgSize","startPos","imgSizeRule","imgSize"],"mappings":"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"}