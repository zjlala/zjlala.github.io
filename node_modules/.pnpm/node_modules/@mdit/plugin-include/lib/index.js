import w from"node:fs";import{NEWLINE_RE as b,dedent as E}from"@mdit/helper";import h from"upath";const I=[/^\/\/ ?#?((?:end)?region) ([\w*-]+)$/,/^\/\* ?#((?:end)?region) ([\w*-]+) ?\*\/$/,/^#pragma ((?:end)?region) ([\w*-]+)$/,/^<!-- #?((?:end)?region) ([\w*-]+) -->$/,/^#((?:End )Region) ([\w*-]+)$/,/^::#((?:end)region) ([\w*-]+)$/,/^# ?((?:end)?region) ([\w*-]+)$/],S=/^( *)<!-{2,}\s*@include:\s*([^<>|:"*?]+(?:\.[a-z0-9]+))(?:#([\w-]+))?(?:\{(\d+)?-(\d+)?\})?\s*-{2,}>\s*$/gm,x=/^( *)@include:\s*([^<>|:"*?]+(?:\.[a-z0-9]+))(?:#([\w-]+))?(?:\{(\d+)?-(\d+)?\})?\s*$/gm,k=(e,r,l,o=!1)=>{const[d,t,n]=r.exec(e.trim())??[];return!!(d&&t&&n===l&&t.match(o?/^[Ee]nd ?[rR]egion$/:/^[rR]egion$/))},y=(e,r)=>{let l=null,o=-1;for(const[d,t]of e.entries())if(l===null){for(const n of I)if(k(t,n,r)){o=d+1,l=n;break}}else if(k(t,l,r,!0))return{lineStart:o,lineEnd:d};return null},$=(e,{cwd:r,includedFiles:l,resolvedPath:o})=>{const{filePath:d}=e;let t=d;if(!h.isAbsolute(d)){if(!r)return console.error(`[@mdit/plugin-include]: Error when resolving path: ${d}`),`
Error when resolving path
`;t=h.resolve(r,d)}if(l.push(t),!w.existsSync(t))return console.error(`[@mdit/plugin-include]: ${t} not found`),`
File not found
`;const n=w.readFileSync(t).toString().replace(b,`
`).split(`
`);let u=[];if("region"in e){const c=y(n,e.region);c&&(u=n.slice(c.lineStart,c.lineEnd))}else{const{lineStart:c,lineEnd:i}=e;if(c)u=n.slice(c-1,i);else if(n[0]==="---"){const s=n.findIndex((f,a)=>a!==0&&f==="---");u=n.slice(Math.max(s+1,1),i)}else u=n.slice(0,i)}if(o&&t.endsWith(".md")){const c=h.dirname(t);u.unshift(`<!-- #include-env-start: ${c} -->`),u.push("<!-- #include-env-end -->")}return E(u.join(`
`).replace(/\n?$/,`
`))},P=(e,r,{cwd:l,includedFiles:o})=>e.replace(r.useComment?S:x,(d,t,n,u,c,i)=>{const s=r.resolvePath(n,l),f=r.resolveImagePath||r.resolveLinkPath,a=$({filePath:s,...u?{region:u}:{...c?{lineStart:Number(c)}:{},...i?{lineEnd:Number(i)}:{}}},{cwd:l,includedFiles:o,resolvedPath:f});return(r.deep&&s.endsWith(".md")?P(a,r,{cwd:h.isAbsolute(s)?h.dirname(s):l?h.resolve(l,h.dirname(s)):null,includedFiles:o}):a).split(`
`).map(m=>t+m).join(`
`)}),F=/^<!-- #include-env-start: ([^)]*?) -->$/,A=(e,r,l,o)=>{const d=e.bMarks[r]+e.tShift[r],t=e.eMarks[r],n=e.src.slice(d,t);if(n.startsWith("<!-- #include-env-start: ")){const u=F.exec(n);if(u){if(o)return!0;const[,c]=u;e.line=r+1;const i=e.push("include_start","",0);return i.map=[r,e.line],i.info=c,i.markup="include_start",!0}}return!1},M=(e,r,l,o)=>{const d=e.bMarks[r]+e.tShift[r],t=e.eMarks[r];if(e.src.slice(d,t)==="<!-- #include-env-end -->"){if(o)return!0;e.line=r+1;const n=e.push("include_end","",0);return n.map=[r,e.line],n.markup="include_end",!0}return!1},_=(e,r,l,o)=>{const d=r.attrIndex(e),t=r.attrs?.[d][1];if(t?.[0]==="."&&Array.isArray(o)){const{length:n}=o;if(n){const u=h.relative(h.dirname(l),o[n-1]),c=h.join(u,t);r.attrs[d][1]=c[0]==="."?c:`./${c}`}}},R=(e,r)=>{const{currentPath:l,resolvePath:o=i=>i,deep:d=!1,resolveLinkPath:t=!0,resolveImagePath:n=!0,useComment:u=!0}=r??{};if(typeof l!="function")throw new Error('[@mdit/plugin-include]: "currentPath" is required');const c=i=>{const s=i.env,f=s.includedFiles??=[],a=l(s);i.src=P(i.src,{currentPath:l,resolvePath:o,deep:d,resolveLinkPath:t,resolveImagePath:n,useComment:u},{cwd:a?h.dirname(a):null,includedFiles:f})};if(e.core.ruler.after("normalize","md_import",c),n||t){if(e.block.ruler.before("table","md_include_start",A,{alt:["paragraph","reference","blockquote","list"]}),e.block.ruler.before("table","md_include_end",M,{alt:["paragraph","reference","blockquote","list"]}),e.renderer.rules.include_start=(i,s,f,a)=>{const m=i[s];return(a.includedPaths??=[]).push(m.info),""},e.renderer.rules.include_end=(i,s,f,a)=>{const m=a.includedPaths;/* istanbul ignore else -- @preserve */return Array.isArray(m)?m.pop():console.error("[@mdit/plugin-include]: include_end failed, no include_start."),""},n){const i=e.renderer.rules.image;e.renderer.rules.image=(s,f,a,m,p)=>{const v=s[f],g=l(m);return g&&_("src",v,g,m.includedPaths),i(s,f,a,m,p)}}if(t){const i=e.renderer.rules.link_open??((s,f,a,m,p)=>p.renderToken(s,f,a));e.renderer.rules.link_open=(s,f,a,m,p)=>{const v=s[f],g=l(m);return g&&_("href",v,g,m.includedPaths),i(s,f,a,m,p)}}}};export{$ as handleInclude,R as include,P as resolveInclude};
//# sourceMappingURL=index.js.map
